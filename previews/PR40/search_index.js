var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Barachant, A.; Bonnet, S.; Congedo, M. and Jutten, C. (2012). Multi-class Brain Computer Interface Classification by Riemannian Geometry. IEEE Transactions on Biomedical Engineering 59, 920–928.\n\n\n\nCongedo, M. (2018). Non-Parametric Synchronization Measures used in EEG and MEG (GIPSA-lab).\n\n\n\nCongedo, M.; Barachant, A. and Bhatia, R. (2017). Riemannian geometry for EEG-based brain-computer interfaces; a primer and a review. Brain-Computer Interfaces 4, 155–174.\n\n\n\nCongedo, M.; Korczowski, L.; Delorme, A. and Silva, F. L. (2016). Spatio-temporal common pattern: A companion method for ERP analysis in the time domain. Journal of Neuroscience Methods 267, 74–88. Epub 2016 Apr 16.\n\n\n\nLedoit, O. and Wolf, M. (2004). A well-conditioned estimator for large-dimensional covariance matrices. Journal of Multivariate Analysis 88, 365–411.\n\n\n\nLedoit, O. and Wolf, M. (2020). The Power of (Non-)Linear Shrinking: A Review and Guide to Covariance Matrix Estimation. Journal of Financial Econometrics, 1–32.\n\n\n\nSearle, S. R. (1982). Matrix Algebra Useful for Statistics (John Wiley & Sons, New York).\n\n\n\nTyler, D. E. (1987). A Distribution-Free M-Estimator of Multivariate Scatter. The Annals of Statistics 15, 234–251.\n\n\n\nZhang, T. and Wiesel, A. (2016). Automatic Diagonal Loading for Tyler's Robust Covariance Estimator. In: IEEE Statistical Signal Processing Workshop (SSP); pp. 1–5.\n\n\n\n","category":"page"},{"location":"Preprocessing/#Preprocessing.jl","page":"Preprocessing","title":"Preprocessing.jl","text":"","category":"section"},{"location":"Preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"This module implements preprocessing for EEG data.","category":"page"},{"location":"Preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"See also Processing.jl","category":"page"},{"location":"Preprocessing/#Methods","page":"Preprocessing","title":"Methods","text":"","category":"section"},{"location":"Preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"Function Description\nEegle.Preprocessing.resample resample EEG data\nEegle.Preprocessing.standardize standardize EEG data\nEegle.Preprocessing.removeChannels remove channels from EEG data\nEegle.Preprocessing.removeSamples remove samples from EEG data\nEegle.Preprocessing.embedLags lag-embedding of EEG data","category":"page"},{"location":"Preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"📖","category":"page"},{"location":"Preprocessing/#StatsBase.standardize","page":"Preprocessing","title":"StatsBase.standardize","text":"    function standardize(X::AbstractArray{T}; \n        robust = false,\n        prop::Real = 0.2) \n    where T<:Real\n\nStandardize the whole TN EEG recording X, where T and N denotes the number of samples and channels (sensors), respectively, using: \n\nthe arithmetic mean and standard deviation of all data in X if robust is false (default)\nthe Winsorized (trimmed) mean and standard deviation of all data in X if robust is true.\n\nThe trimmed statistics are computed excluding the prop proportion of data at both sides (default=0.2), thus, prop is used only if robust is true.\n\nExample\n\nusing Eegle # or using Eegle.Preprocessing\n\nX = randn(1024, 19)\n\nstX = standardize(X)\n\nstX = standardize(X; robust=true, prop=0.1)\n\n\n\n\n\n","category":"function"},{"location":"Preprocessing/#DSP.Filters.resample","page":"Preprocessing","title":"DSP.Filters.resample","text":"    function resample(  X::AbstractMatrix{T},\n                        sr::S,\n                        rate::Union{T, S, Rational};\n        Nϕ::Integer = 32,\n        rel_bw::Float64 = 1.0,\n        attenuation::Int = 60,\n        stim::Union{Vector{S}, Nothing} = nothing) \n    where {T<:Real, S<:Int}\n\nResampling of an EEG data matrix using the polyphase FIR filter with Kaiser window filter taps,   as per the resample method in DSP.jl.\n\nArguments\n\nX: the TN EEG matrix, where T and N denotes the number of samples and channels (sensors), respectively\nsr: the original sampling rate of X\nrate: the resampled data will have sampling rate sr * rate.\n\nOptional Keyword Arguments\n\nNϕ, rel_bw and attenuation: see resample.\na stimulation vector. If it is passed, it will be resampled so as to match the resampling of X as precisely as possible. stim must be a vector of T integers.\n\ntip: Resampling\nIf you need to work with individual trials (or epochs), do not resample trials individually; rather, resample the whole EEG recording and then extract the trials — see Eegle.ERPs.trials. Function Eegle.InOut.readNY allows you to do resampling and extract trials this way.\n\nwarning: Downsampling\nDownsampling must be always preceeded by low-pass filtering to ensure the suppression of all energies above the Nyquist frequency (s2), where s is the new sampling rate after downsampling. The cut_off frequencies is usually taken as s3 and a sharp filter is used (see examples).  This applies also if you wish to apply downsampling by decimation — see the examples for decimating in Eegle.Miscellaneous.remove and removeSamples.\n\nReturn the resampled data matrix.   \n\nExamples\n\nusing Eegle # or using Eegle.Preprocessing\n\nsr = 512\nX = randn(sr*10, 19)\n\n# low-pass filter at s/3 = sr/(4*3) Hz and downsample by a factor 4\nZ = filtfilt(X, sr, Bandpass(1, sr/(4*3)); designMethod = Butterworth(8))\nY = resample(Z, sr, 1//4) \n\nY = resample(X, sr, 2) # upsample by a factor 2, i.e., double the sampling rate\n\nsr = 100\nX = randn(sr*10, 19)\nY = resample(X, sr, 128/sr) # upsample to 128 samples per second\n\n\n\n\n\n","category":"function"},{"location":"Preprocessing/#Eegle.Preprocessing.removeChannels","page":"Preprocessing","title":"Eegle.Preprocessing.removeChannels","text":"    function removeChannels(X::AbstractMatrix{T}, \n                            what::Union{Int, Vector{S}},\n                            sensors::Vector{String}) \n    where {T<:Real, S<:Int}\n\n\nRemove one or more channels, i.e., columns, from the TN EEG recording X,  where T and N denotes the number of samples and channels (sensors), respectively, and remove the corresponding elements from sensors, the provided associated vector of N sensor labels.\n\nFor the use of kwarg what, see method Eegle.Miscellaneous.remove, which can be used instead of this function if you do not need to remove channels from a sensor labels vector.\n\nReturn the 3-tuple (newX, s, ne), where newX is the new EEG recording, s is the new sensor labels vector and ne is the new number of channels (sensors) in newX (s).\n\nSee Also Eegle.InOut.readSensors\n\nExamples\n\nusing Eegle # or using Eegle.Preprocessing\n\nusing Eegle # or using Eegle.Preprocessing\n\nX = randn(128, 7)\nsensors = [\"F7\", \"F8\", \"C3\", \"Cz\", \"C4\", \"P7\", \"P8\"]\n\n# remove second channel\nX_, sensors_, ne = removeChannels(X, 2, sensors)\n\n# remove the first five channels\nX_, sensors_, ne = removeChannels(X, collect(1:5), sensors)\n\n# remove the channel labeled as \"Cz\" in `sensors`\nX_, sensors_, ne = removeChannels(X, findfirst(x->x==\"Cz\", sensors), sensors)\n\n# remove the channels labeled as \"C3\", \"Cz\", and \"C4\" in `sensors`\nX_, sensors_, ne = removeChannels(X, findall(x->x∈(\"Cz\", \"C3\", \"C4\"), sensors), sensors)\n\n# keep only channels labeled as \"C3\", \"Cz\", and \"C4\" in `sensors`\nX_, sensors_, ne = removeChannels(X, findall(x->x∉(\"Cz\", \"C3\", \"C4\"), sensors), sensors)\n\n\n\n\n\n","category":"function"},{"location":"Preprocessing/#Eegle.Preprocessing.removeSamples","page":"Preprocessing","title":"Eegle.Preprocessing.removeSamples","text":"    function removeSamples( X::AbstractMatrix{T}, \n                            what::Union{Int, Vector{S}},\n                            stim::Vector{S}) \n    where {T<:Real, S<:Int}\n\n\nRemove one or more samples, i.e., rows, from the TN EEG recording X,  where T and N denotes the number of samples and channels (sensors), respectively, and remove the corresponding elements from stim, the associated stimulation vector.\n\nFor the use of kwarg what, see method Eegle.Miscellaneous.remove, which can be used instead of this function if you do not need to remove tags from a stimulation vector.\n\nPrint a warning if elements in what correspond to non-zero tags in stim.\n\nReturn the 3-tuple (newX, s, ne), where newX is the new data, s is the new stimulation vector and ns is the new number of samples in newX.\n\nExamples\n\nusing Eegle\n\nsr, ne = 256, 7\nX = randn(sr, ne)\nstim = rand(0:3, sr)\n\n# remove second sample\nX_, stim_, ns = removeSamples(X, 2, stim)\n\n# remove the first 128 samples\nX_, stim_, ns = removeSamples(X, collect(1:128), stim)\n\n# remove every other sample (decimation by a factor of 2)\nX_, stim_, ns = removeSamples(X, collect(1:2:length(stim)), stim)\n\n\n\n\n\n","category":"function"},{"location":"Preprocessing/#Eegle.Preprocessing.embedLags","page":"Preprocessing","title":"Eegle.Preprocessing.embedLags","text":"    function embedLags( X::AbstractMatrix{T}, \n                        lags = 0) \n    where T<:Real \n\nLag-embedding is a technique to augment the data. Second-order statistics of the augmented data, that is, covariance or cross-spectral matrices, hold information not only of volume condution and instantaneous connectivity, but also of lagged connectivity. These matrices can be used, for example, in blind source separation and Riemannian classification.\n\nTutorials xxx, xxx\n\nDescription\n\nGiven the TN EEG recording X, where T and N denotes the number of samples and channels (sensors), respectively,  and L0 lags, the TN(L+1) lag-embedded data matrix is\n\nX_textlags = left \nX^(0)  X^(1)  cdots  X^(L)\nright\n\nwhere, letting mathbf0_A times B the A times B matrix of zeros, for each l = 0 ldots L, the TN lagged partition X^(l) is defined as\n\nX^(l) = left\nbeginmatrix\nmathbf0_(L - l) times N \nX1(T - L)   \nmathbf0_l times N\nendmatrix\nright\n\nNotice that the are no zeros appended to the first partition and no zeros prepended to the last partition. Notice also that the lag-embedded data has the same size of the input, however the last L samples are lost.\n\nReturn the TN(L+1) lag-embedded data matrix X_textlags.\n\nExample\n\nusing Eegle # or using Eegle.Preprocessing\n\nX = randn(8, 2) # small example to see the effect\n\nelX = embedLags(X, 3)\n\n\n\n\n\n","category":"function"},{"location":"InOut/#InOut.jl","page":"Input/Output","title":"InOut.jl","text":"","category":"section"},{"location":"InOut/","page":"Input/Output","title":"Input/Output","text":"This module declares a structure for EEG-based BCI data and methods for reading and writing data","category":"page"},{"location":"InOut/#Methods","page":"Input/Output","title":"Methods","text":"","category":"section"},{"location":"InOut/","page":"Input/Output","title":"Input/Output","text":"Function Description\nEegle.InOut.EEG a structure for EEG-based BCI holding data and metadata\nEegle.InOut.readNY read EEG/BCI data in NY format as an EEG structure\nEegle.InOut.readgTec read EEG data recorded by the g.Tec g.Recorder software\nEegle.InOut.readASCII read EEG data in ASCII text format (2 methods)\nEegle.InOut.readSensors read EEG sensor labels from an ASCII text file\nEegle.InOut.writeASCII write EEG data in ASCII text format (3 methods)","category":"page"},{"location":"InOut/","page":"Input/Output","title":"Input/Output","text":"📖","category":"page"},{"location":"InOut/#Eegle.InOut.EEG","page":"Input/Output","title":"Eegle.InOut.EEG","text":"    struct EEG\n        id            :: Dict{Any,Any} \n        acquisition   :: Dict{Any,Any} \n        documentation :: Dict{Any,Any} \n        formatversion :: String        \n\n        # the following fields are those most useful in practice\n        db            :: String        \n        subject       :: Int           \n        session       :: Int           \n        run           :: Int           \n        sensors       :: Vector{String}\n        sr            :: Int           \n        ne            :: Int           \n        ns            :: Int           \n        wl            :: Int           \n        offset        :: Int           \n        nc            :: Int           \n        clabels       :: Vector{String} \n        stim          :: Vector{Int}    \n        mark          :: Vector{Vector{Int}}  \n        y             :: Vector{Int}          \n        X             :: Matrix{T} where T<:Real \n        trials        :: Union{Vector{Matrix{T}}, Nothing} \n    where T<:Real \n\nData structure for an EEG BCI (Brain-Computer Interface) session, holding data and metadata.\n\nIt is written by readNY.\n\nWhile conceived specifically for BCI sessions, the structure can be used also for general EEG recordings.\n\nFields\n\ndb: name of the database to which the recording belongs\nsubject: serial number of the present subject in the above database\nsession: serial number of the present session for the above subject\nrun: serial number of the present run of the above session\nsensors: labels of the scalp electrode leads in standard notation (10-20, 10-10,...)\nsr: sampling rate in samples\nne: number of electrode leads\nns: number of samples \nwl: window length in samples. Typically, the duration of a BCI trial\noffset: see offset\nnc: number of classes (non-zero tags)\nclabels: labels of the classes\nstim: the stimulation vector\nmark: the marker vectors \ny: the markers in vectors mark concatenated in an unique vector\nX: the TN EEG data, with T and N the number of samples and channels (sensors), respectively\ntrials: a vector of trials, each of size Nwl, extracted in the order of tags given in stim (optional)\nthe keys for dictionaries id, acquisition, and documentation are — see NY Metadata (YAML)):\n\nid acquisition documentation\n\"run\" \"sensors\" \"doi\"\n\"timestamp\" \"software\" \"repository\"\n\"database\" \"ground\" \"description\"\n\"subject\" \"reference\" \"investigators\"\n\"session\" \"filter\" \"place\"\n\"condition\" \"sensortype\" \n\"paradigm\" \"samplingrate\" \n \"hardware\" \n\nIn Julia, a structure has a default constructor taking all fields as arguments. A simplified constructor is also available, as\n\n    EEG(    X::Matrix{T}, \n            sr::Int, \n            sensors::Vector{String};\n        db::String = \"\",\n        subject::Int = 0,\n        session::Int = 1,\n        run::Int = 1,\n        wl::Int = sr,\n        offset::Int = 0,\n        nc::Int = 1,\n        clabels::Vector{String} = [\"\"],\n        stim::Vector{Int} = [\"0\"],\n        mark::Vector{Vector{Int}} = [[\"\"]],\n        y::Vector{Int} = [0])\n    where T<:Real\n\nThe above creates an EEG structure providing, ad minima:\n\nthe EEG data X\nthe sampling rate sr\nthe sensor labels sensors.\n\nThe kwarg of this constructor are useful fields that can be filled. The dictionaries of the structure are left empty.\n\n\n\n\n\n","category":"type"},{"location":"InOut/#Eegle.InOut.readNY","page":"Input/Output","title":"Eegle.InOut.readNY","text":"    function readNY(filename :: AbstractString;\n        toFloat64   :: Bool = true,\n        bandStop    :: Tuple = (),\n        bandPass    :: Tuple = (),\n        bsDesign    :: DSP.ZeroPoleGain = Butterworth(8),\n        bpDesign    :: DSP.ZeroPoleGain = Butterworth(4),\n        rate        :: Union{Real, Rational, Int} = 1,\n        upperLimit  :: Union{Real, Int} = 0,\n        getTrials   :: Union{Bool, Vector{String}} = true, \n        stdClass    :: Bool = true, \n        msg         :: String=\"\") \n\nRead EEG/BCI data in NY format, prepreprocess them if desired, and create an EEG structure.\n\nIf requested, the preprocessing operations are performed in the order of the kwargs.\n\nArguments\n\nfilename: the complete path of either the .npz or the .yml file of the recording to be read.\n\nOptional Keyword Arguments\n\ntoFloat64: if true, the EEG data is converted to Float64 if it is not already (default: true)\nbandStop: a 2-tuple holding the limits in Hz of a notch filter (default: no filter)\nbandPass: a 2-tuple holding the limits in Hz of a band-pass filter (default: no filter)\nbsDesign: the filter design method for the notch filter passed to filtfilt (default: Butterworth(8))\nbpDesign: the filter design method for the band-pass filter passed to filtfilt (default: Butterworth(4))\nrate: argument passed to resample for resampling the data (default: 1, no resampling)\nupperLimit: argument passed to Eegle.ERPs.reject for artifact rejection (default: 0, no artifact rejection)\ngetTrials: \nif true (default), the .trials field of the EEG structure is filled with the trials for all classes\nIf it is a vector of class labels (strings), only the trials with those class labels will be stored    For example, getTrials=[\"left_hand\", \"right_hand\"] will store only the trials corresponding to \"left_hand\" class label   and \"right_hand\" class label. The tags corresponding to each class labels will be replaced by natural numbers (1, 2,...)    and written in the .stim field of the output — see stimulation vector\nIf false, the field trials of the returned EEG structure will be set to nothing.\nstdClass: \nif true (default), class labels are standardized according to predefined conventions to facilitate transfer learning   and model training across heterogeneous databases.   The standardization applies uniform numerical codes regardless of the original database encoding:\nMI paradigm: \"left_hand\" → 1, \"right_hand\" → 2, \"feet\" → 3, \"rest\" → 4, \"both_hands\" → 5, \"tongue\" → 6\nP300 paradigm: \"nontarget\" → 1, \"target\" → 2\nERP paradigm: not currently supported\nif false, original class labels and their corresponding numerical values are preserved as found in the database\nThe standardization is case-insensitive but requires correct spelling of class names.   When used with getTrials as a vector of class labels, standardization is applied after class selection.   If class labels are already standardized, the original mapping is preserved.   Ii is recommended to set stdClass to true when all relevant classes are available in your database configuration.\nmsg: print string msg on exit if it is not empty. By default it is empty.\n\nnote: Resampling\nIf you use resampling, the new sampling rate will be rounded to the nearest integer.\n\nwarning: stim and mark\nIf the field offset of the NY file is different from zero, the stimulations in stim and markers in mark will be shifted to account for the offset - see stimulation vector. Offset will then be reset to zero. \n\nReturn an EEG data structure.\n\nSee Also readASCII, readgTec, Eegle.ERPs.mark2stim, Eegle.ERPs.stim2mark\n\nExamples\n\nxxx\n\n\n\n\n\n","category":"function"},{"location":"InOut/#Eegle.InOut.readgTec","page":"Input/Output","title":"Eegle.InOut.readgTec","text":"    function readgTec(fileName::AbstractString;\n        dataType::Type = Float32,\n        writeMetaDataFiles::Bool = true,\n        verbose::Bool = true,\n        skipFirstSamples::Int = 0,\n        chRange::Union{UnitRange, Symbol} = :All)\n\n\nRead an EEG data file saved in HDF5 format by the g.Tec g.Recorder software.\n\nArguments\n\nfileName: the complete path of the .hdf5 file to be read.\n\nOptional Keyword Arguments\n\ndataType: Float32 by default. Can be Float64.\nwriteMetaDataFiles: true by default. All metadata files will be   saved as .xml or .txt files, in the same director where filename is   with the same name to which a suffix indicating the type of metadata   will be appended.   If writeMetaDataFiles is true and verbose is true (default),   the metadata will be shown in the REPL.\nskipFirstSamples: if greater than 0 (default), this number of samples   at the beginning of the file will not be read. \nchRange: if a unit range is provided (e.g., 1:10), only this range of channels   will be read. All channels are read by default.\n\nReturn\n\nThe EEG data as a TN matrix, where T and N denotes the number of  samples and channels, respectively.\n\nSee Also readASCII, readNY\n\nExamples\n\nxxx\n\n\n\n\n\n","category":"function"},{"location":"InOut/#Eegle.InOut.readASCII","page":"Input/Output","title":"Eegle.InOut.readASCII","text":"(1) function readASCII(fileName::AbstractString; \n        msg::String=\"\")\n\n(2) readASCII(  fileNames::Vector{String}, \n                skip::Vector{Int}=[])        \n\nRead EEG data from one file (method 1) or several files (method 2) in LORETA-Key  format. The format is a space- or tab-delimited ASCII file, usually with extension .txt, holding a matrix of data with N columns and T rows,  denoting the number of channels and samples, respectively. \n\n(1) fileName is the full path to the ASCII file. \n\nIf kwarg msg is not empty, print msg on exit.\n\n(2) fileNames is a vector of the full paths to the ASCII files. \n\nIf kwarg skip is a vector of indices (integers), skip the files with these indices (empty by default).\n\nReturn\n\n(1) The EEG data as a TN matrix, where T and N denote the number of  samples and channels, respectively.\n\n(2) A vector of matrices as in (1).\n\nSee Also writeASCII, readgTec, readNY\n\n\n\n\n\n","category":"function"},{"location":"InOut/#Eegle.InOut.readSensors","page":"Input/Output","title":"Eegle.InOut.readSensors","text":"    function readSensors(fileName::String; \n        hasHeader::Bool=true)\n\nRead a list of EEG sensor labels from ASCII file fileName. The file has one label per line.\n\nIf hasHeader is true (default), the first line is the number of labels.\n\nAn example file looks like the trasnpose of this:\n\n3 Fz Pz Cz\n\nExamples\n\nsensors = readSensors(fileName)\n\n\n\n\n\n","category":"function"},{"location":"InOut/#Eegle.InOut.writeASCII","page":"Input/Output","title":"Eegle.InOut.writeASCII","text":"(1) function writeASCII(X::Matrix{T}, \n                        fileName::String;\n        samplesRange::UnitRange = 1:size(X, 1),\n        overwrite::Bool = false,\n        digits = 6,\n        msg::String = \"\") \n    where T <: Real\n\n(2) function writeASCII(X::Matrix{S}, \n                        fileName::S;\n        overwrite::Bool = false,\n        msg::S = \"\") \n    where S <: String\n\n(3) function writeASCII(v::Vector{S}, \n                        fileName::S;\n        samplesRange::UnitRange = 1:size(v, 1),\n        overwrite::Bool = false,\n        oneline::Bool = false,\n        msg::S = \"\")\n    where S <: String\n\n(1)\n\nWrite a data matrix X into an ASCII text file that can be read by readASCII.\n\nArguments\n\nX: a Julia matrix of real numbers.\nfileName: the full path of the file to be saved, usually with extension .txt.\n\nOptional Keyword Arguments\n\nsamplesRange: the unit range of rows of X (samples for ASCII EEG data files) to be written. Default: 1:T\noverwrite: if false (default), return an error if fileName is an existing file\ndigits: the number of decimal digits written for each value. Default: 6\nmsg: print string msg on exit if it is not empty (empty by default).\n\nIf you need to remove columns of X before writing, see Eegle.Miscellaneous.remove or removeChannels.\n\n(2)\n\nWrite a matrix of strings into an ASCII file.\n\nArguments\n\nX: the matrix of string to be written\nfileName: as in (1).\n\nOptional Keyword Arguments\n\noverwrite and msg: as in (1).\n\n(3)\n\nWrite a vector of strings into an ASCII text file.\n\nArguments\n\nv: the vector of string to be written\nfileName: as in (1).\n\nOptional Keyword Arguments\n\nsamplesRange: a unit range of elements of v to be written (all elements by default)\noverwrite and msg: as in (1)\noneline: \nif true, write all elements in the first line delimiting them by a space\nif false (default), write one element per line.\n\ntip: End of line\nAll methods include character \"\\r\\n\" (ASCII end of line and carriage return) at the end of each line. Visualizing these files properly with a standard text editor may require some care on Linux.\n\nExamples\n\nxxx\n\n\n\n\n\n","category":"function"},{"location":"Processing/#Processing.jl","page":"Processing","title":"Processing.jl","text":"","category":"section"},{"location":"Processing/","page":"Processing","title":"Processing","text":"This module implements Processing for EEG data.","category":"page"},{"location":"Processing/","page":"Processing","title":"Processing","text":"See also Preprocessing.jl","category":"page"},{"location":"Processing/#Methods","page":"Processing","title":"Methods","text":"","category":"section"},{"location":"Processing/","page":"Processing","title":"Processing","text":"Function Description\nEegle.Processing.filtfilt digital filetring of EEG data\nEegle.Processing.centeringMatrix the centering matrix (for computing the common average reference)\nEegle.Processing.globalFieldPower global field power\nEegle.Processing.globalFieldRMS global field root mean square\nEegle.Processing.epoching epoching of spontaneous EEG","category":"page"},{"location":"Processing/","page":"Processing","title":"Processing","text":"📖","category":"page"},{"location":"Processing/#DSP.Filters.filtfilt","page":"Processing","title":"DSP.Filters.filtfilt","text":"    function filtfilt(  X::Matrix, \n                        sr::Int, \n                        responseType::DSP.FilterType; \n        designMethod::DSP.ZeroPoleGain=Butterworth(2))\n\nApply a digital filter in a forward-backward manner to obtain a linear phase response.\n\nArguments\n\nX: the TN EEG recording, where T and N denotes the number of samples and channels (sensors), respectively\nsr: the sampling rate of X\nresponseType: a filter response type of the DSP.jl package: Lowpass, Highpass, Bandpass, or Bandstop\ndesignMethod: The filter design method of the DSP.jl package: Butterworth, Chebyshev1, Chebyshev2, Elliptic, or FIRWindow.\n\nBy default, designMethod is Butterworth(2), that is, a second-order Butterworth filter.\n\nFor the analysis in the frequency domain — see the FourierAnalysis package.\n\nExamples\n\nusing Eegle\n\nX, sr = randn(1024, 19), 128\n\nfilteredX = filtfilt(X, sr, Bandpass(1, 24))\n\nfilteredX = filtfilt(X, sr, Bandstop(1, 24))\n\nfilteredX = filtfilt(X, sr, Highpass(10))\n\nfilteredX = filtfilt(X, sr, Lowpass(10))\n\nfilteredX = filtfilt(X, sr, Bandstop(1, 24); \n                    designMethod = Chebyshev1(4, 0.5))\n\n# Apply a filter bank\nresponses = [Bandpass(1, 4), Bandpass(4, 8), Bandpass(8, 12), Bandpass(12, 16)]\nfilterBank = [filtfilt(X, 128, r) for r∈responses]\n\n\n\n\n\n","category":"function"},{"location":"Processing/#Eegle.Processing.centeringMatrix","page":"Processing","title":"Eegle.Processing.centeringMatrix","text":"    function centeringMatrix(d::Int)\n\nThe common average reference (CAR) operator for referencing EEG data  potentials so that their mean across sensors (space) is zero at all samples.\n\nLet X be the TN EEG recording, where T and N denotes the number of samples and channels (sensors), respectively, and let H_N be the NN recentering matrix, then \n\nY=XH \n\nis the CAR (or centered) data.\n\nH_N is named the common average reference operator. It is given at p.67 by (Searle, 1982), as\n\nH_N = I_d - frac1d left( mathbf1_d mathbf1_d^top right)\n\nwhere I_d is the d-dimensional identity matrix and mathbf1_d is the d-dimensional vector of ones.\n\nAlias ℌ (U+0210C, with escape sequence \"frakH\")\n\nReturn the dd centering matrix.\n\nExamples\n\nusing Eegle\n\nX = randn(128, 19)\n\n# CAR\nX_car = X * centeringMatrix(size(X, 2))\n# or\nX_car = X * ℌ(size(X, 2))\n\n# double centered data: zero mean across time and space\nX_dc = ℌ(size(X, 1)) * X * ℌ(size(X, 2))\n\n\n\n\n\n","category":"function"},{"location":"Processing/#Eegle.Processing.globalFieldPower","page":"Processing","title":"Eegle.Processing.globalFieldPower","text":"    function globalFieldPower(X::AbstractMatrix{T}; \n        func=identity) \n    where T<:Real \n\nThe global field power (GFP) is the sample-by-sample total EEG power.\n\nLet X be the TN EEG recording, where T and N denotes the number of samples and channels, respectively, and x_t be the vector of N potentials at sample t1T, then the GFP at each sample is given by\n\nx_t^Tx_t.\n\nFunction func can be applied element-wise to the output (none by default).\n\nUsually the GFP is computed on common average reference data — see centeringMatrix.\n\nReturn the vector comprising the T GFP values.\n\nSee also globalFieldRMS\n\nExamples\n\nusing Eegle\n\nX=randn(128, 19)\n\ng = globalFieldPower(X * ℌ(size(X, 2)); func=log)\n# ℌ is an alias for centeringMatrix\n\n\n\n\n\n","category":"function"},{"location":"Processing/#Eegle.Processing.globalFieldRMS","page":"Processing","title":"Eegle.Processing.globalFieldRMS","text":"    function globalFieldRMS(X::AbstractMatrix{T}; \n        func=identity) \n    where T<:Real\n\nThe global field root mean square (GFRMS) is the square root of the globalFieldPower once this has been divided by the number of electrodes.\n\nLet X be the TN EEG recording, where T and N denotes the number of samples and channels, respectively, and let x_t be the vector of N potentials at sample t1T, then the GFRMS at each sample is given by\n\nsqrtfrac1N (x_t^top x_t).\n\nFunction func can be applied element-wise to the output (none by default).\n\nUsually the GFRMS is computed on common average reference data — see centeringMatrix.\n\nReturn the vector comprising the T GFRMS values.\n\nSee also globalFieldPower\n\nExamples\n\nusing Eegle\n\nX=randn(128, 19)\n\ng = globalFieldRMS(X * ℌ(size(X, 2)); func=x->x^2)\n# ℌ is an alias for centeringMatrix\n\n\n\n\n\n","category":"function"},{"location":"Processing/#Eegle.Processing.epoching","page":"Processing","title":"Eegle.Processing.epoching","text":"    function epoching(X::AbstractMatrix{T}, sr;\n        wl::Int = round(Int, sr*1.5),\n        slide::Int = 0,\n        minSize::S = round(Int, sr*1.5),\n        lowPass::Union{T, S} = 14,\n        richReturn::Bool = false) \n    where {T<:Real, S<:Int}\n\nSegment an EEG file in successive epochs and compute a vector of unit ranges delimiting the epochs. This is used to extract epochs from spontaneous EEG recording. For tagged data (e.g., ERPs and BCI data),  use Eegle.ERPs.trials instead.\n\nTwo segmentation methods are possible, the standard fixed-length epoching and the adaptive epoching based on the local minima of the low-pass filtered global field root mean square (GFRMS).\n\nStandard: wl must be set to a positive integer (by default is 0), which determines the length in samples of the epochs.   A positive value of slide (default=0) determines the number of overlapping    samples. By default there will be no overlapping. \nAdaptive: if wl=0 (default), the GFRMS is computed, low-pass filtered    using lowPass (in Hz) as the cutoff (default = 14 Hz) and segmented ensuring that the minimum epoch size (in samples) is minSize,    which default is the nuber of samples covering 1.5s.\n\nReturn\n\nStandard: if richReturn=false (default) r, else the 3-tuple (r, 0 and wl)\nAdaptive: if richReturn=false (default) r, else the 3-tuple (r, m, l),\n\nwhere r is the computed vector of unit ranges (a Vector{UnitRange{Int64}} type),  m the vector with the low-pass filtered GFMRS and l the vector of epoch lengths.\n\nnote: Epochs definition\nWith the adaptive method, the last sample of an epoch coincides with the first sample of the successive epoch, whereas with the standard method there is no overlapping if slide is equal to 0 (default).\n\nExamples\n\n\nusing Eegle\n\nX=randn(6144, 19)\nsr = 128\n\n# standard 1s epoching with 50% overlap\nranges = epoching(X, sr;\n        wl = sr,\n        slide = sr ÷ 2)\n# return (1:64, 65:128, ...)\n\n# standard 4s epoching with no overlap\nranges = epoching(X, sr;\n        wl = sr * 4)\n# return (1:512, 513:1024, ...)\n\n# adaptive epoching of θ (4Hz-7.5Hz) oscillations\nXθ = filtfilt(X, sr, Bandpass(4, 7.5))\nranges = epoching(Xθ, sr;\n        minSize = round(Int, sr ÷ 4), # at least one θ cycle\n        lowPass = 7.5)  # ignore minima due to higher frequencies\n\n# Get the epochs from any of the above:\n𝐗 = [X[r, :] for r ∈ ranges] # or 𝐗 = [Xθ[r, :] for r ∈ ranges]\n\n# Get the covariance matrices of the epochs from any of the above\n𝐂 = covmat(𝐗) # See CovarianceMatrices.jl\n\n# If only the covariance matrices are needed,\n# a more memory-efficient way skipping the extraction of 𝐗 is\n𝐂 = ℍVector(covmat([view(X, r, :) for r ∈ ranges]))\n𝐂θ = ℍVector(covmat([view(Xθ, r, :) for r ∈ ranges]))\n\nSee Eegle.BCI.covmat\n\n\n\n\n\n","category":"function"},{"location":"BCI/#BCI.jl","page":"Brain-Computer Interface","title":"BCI.jl","text":"","category":"section"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"This module implements machine learning for EEG data and, particularly, brain-computer interface data, using Riemannian geometry. Data encoding is achieved by estimating a form of covariance matrix for the EEG epochs or BCI trials.","category":"page"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"For tutorials, see Machine Learning. ","category":"page"},{"location":"BCI/#Resources-for-Covariance-Matrices","page":"Brain-Computer Interface","title":"Resources for Covariance Matrices","text":"","category":"section"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"For manipulating covariance matrices using Riemannian geometry — see package PosDefManifold.jl.","category":"page"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"For machine learning based on Riemannian geometry — see package PosDefManifoldML.jl.","category":"page"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"For methods based on the diagonalization of one or more covariance matrices, see package Diagonalizations.jl.","category":"page"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"Fourier cross-spectra and coherence matrices are special forms of covariance matrices. For producing them, see FourierAnalysis.jl.","category":"page"},{"location":"BCI/#Methods","page":"Brain-Computer Interface","title":"Methods","text":"","category":"section"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"Function Description\nEegle.BCI.covmat Many covariance matrix estimators (2 methods)\nEegle.BCI.encode Encode all trials in a given EEG recording using Riemannian geometry\nEegle.BCI.crval Encode all trials in a given EEG recording using Riemannian geometry","category":"page"},{"location":"BCI/","page":"Brain-Computer Interface","title":"Brain-Computer Interface","text":"📖","category":"page"},{"location":"BCI/#Eegle.BCI.covmat","page":"Brain-Computer Interface","title":"Eegle.BCI.covmat","text":"(1) function covmat(X::AbstractMatrix{T};\n        covtype = SCM,\n        prototype::Union{AbstractMatrix, Nothing} = nothing,\n        standardize::Bool = false,\n        useBLAS::Bool = true,\n        threaded::Bool = true,\n        reg::Symbol = :rmt,\n        tol::Real = real(T)(1e-6),\n        maxiter::Int = 200,\n        verbose::Bool = false) \n    where T<:Union{Real, Complex}\n\n(2)  function covmat(𝐗::AbstractVector{<:AbstractArray{T}};\n        < same arguments as method (1) > ...\n\nCovariance matrix estimation(s) of a single data matrix (e.g., a trial) X (1) or of a vector of K data matrices 𝐗 (2).\n\nArguments\n\n(1) X: NT real data matrix, where N and T denotes the number of samples and channels, respectively\n(2) 𝐗: a vector holding k such matrices.\n\nOptional Keyword Arguments\n\ncovtype: covariance estimator (default = SCM):\nSCM : sample covariance matrix (maximum likelihood)\nLShrLW : linear shrinkage estimator of (Ledoit and Wolf, 2004)\nNShrLW : non-linear shrinkage estimator of (Ledoit and Wolf, 2020)\n:Tyler: Tyler's M-estimator (Tyler, 1987)\n:nrTyler: normalized regularized Tyler's M-Estimator (Zhang and Wiesel, 2016)\nor any estimator from the CovarianceEstimation.jl package.\nprototype: optional matrix to be stacked to the data matrix (or matrices) to form a super-trial — see Appendix I in (Congedo et al., 2017). Default = nothing\nstandardize: if true, standardize the data matrix(ces) (global mean = 0 and global sd = 1 for each matrix) before estimating the covariance. Default = false\nuseBLAS: optimize the SCM covariance computations using BLAS. Default = true\nthreaded: enable multi-threading across the k matrices. For (2) only. Default = true\nOnly for M-estimators:\ntol: the tolerance for the stopping criterion of the iterative algorithm (default = 1e-6)\nmaxiter: the maximum number of iterations allowed (default = 200)\nverbose: if true, information about convergence is printed in the REPL (default = false).\nOnly for the normalized regularized Tyler's M-Estimator. Default = :rmt:\nreg: if it is :rmt, the random matrix theory shrinkage is used, otherwise the Ledoit and Wolf linear shrinkage is used.\n\nReturn\n\n(1): The covariance matrix estimation as a Julia Hermitian matrix\n(2): A vector of K covariance matrix estimations as an HermitianVector type.\n\nExamples\n\nusing Eegle # or using Eegle.BCI\n\n# Method (1)\n\nC = covmat(randn(128, 19)) # sample covariance matrix\n\nC = covmat(randn(128, 19); covtype=LShrLW)\n\nC = covmat(randn(128, 19); covtype=:Tyler)\n\n# Method (2)\n\n𝐗 = [randn(128, 19) for k=1:10]\n\n𝐂 = covmat(𝐗)\n\nC = covmat(𝐗; covtype=LShrLW)\n\nC = covmat(𝐗; covtype=:Tyler)\n\n\n\n\n\n","category":"function"},{"location":"BCI/#Eegle.BCI.encode","page":"Brain-Computer Interface","title":"Eegle.BCI.encode","text":"    function encode(o::EEG, paradigm::Symbol;\n        covtype=SCM,\n        targetLabel::String = \"\",\n        overlapping::Bool = false,\n        weights = :a,\n        pcadim::Int = 8,\n        standardize::Bool = false,\n        tikh :: Union{Real, Int} = 0,\n        useBLAS :: Bool = true,\n        threaded = true,\n        reg::Symbol = :rmt,\n        tol::Real = 1e-6,\n        maxiter::Int = 200,\n        verbose::Bool = false)\n\nEncode all trials in an EEG recording as covariance matrices for a given BCI paradigm. This is used in Riemannian geometry machine learning. The supported BCI paradigms are Motor Imagery (MI), Event-Related Potentials (ERP) and P300. For details, see Appendix I in (Congedo et al., 2017).\n\nArguments\n\no: an instance of the EEG data structure containing trials and metadata\nparadigm: BCI paradigm, either :ERP, :P300, or :MI:\nfor :ERP, prototypes for all classes are stacked and covariance is computed on super-trials\nfor :P300, only the target class prototype is stacked\nfor :MI, no prototype is used; covariance is computed on the trial as it is.\n\nOptional Keyword Arguments\n\ncovtype, standardize, useBLAS, reg, tol, maxiter and verbose — see Eegle.BCI.covmat, to which they are passed.\ntargetLabel: mandatory label of the target class (P300 paradigm only, usually: \"target\")\noverlapping: for prototype mean ERP estimations (ERP/P300 only). Default = false:\nif true, use multivariate regression\nif false, use the arithmetic average — see mean.\nweights: weights for prototype mean ERP estimations (ERP/P300 only). Default = :a — see mean\npcadim: number of PCA components of the prototype. They replace the prototype (ERP/P300 only, default = 0, which does not apply PCA)\nstandardize: standardize trials and prototype (global mean 0 and sd 1) before covariance estimation (default: false)\ntikh: Tikhonov regularization parameter (0, the default, does not apply regularization). It is applied after covariance estimation\nthreaded: enable multi-threaded covariance estimations across trials (default: true). \n\nThrow\n\nArgumentError if class label targetLabel is not found in o.clabels (for P300 paradigm).\nArgumentError if paradigm is not one of :ERP, :P300, or :MI.\n\nReturn A vector of k covariance matrix estimations as a HermitianVector type.\n\nExamples\n\nusing Eegle # or using Eegle.BCI\nxxx\n\n\n\n\n\n","category":"function"},{"location":"BCI/#PosDefManifoldML.crval","page":"Brain-Computer Interface","title":"PosDefManifoldML.crval","text":"    function crval( filename    :: AbstractString, \n                    paradigm    :: Symbol, \n                    model       :: MLmodel = MDM(Fisher);\n            # Arguments passed to both encode and crval\n            verbose     :: Bool = true,\n            threaded    :: Bool = true,\n            # Arguments passed to readNY\n            toFloat64   :: Bool = true,\n            bandStop    :: Tuple = (),\n            bandPass    :: Tuple = (),\n            bsDesign    :: DSP.ZeroPoleGain = Butterworth(8),\n            bpDesign    :: DSP.ZeroPoleGain = Butterworth(4),\n            rate        :: Union{Real, Rational, Int} = 1,\n            upperLimit  :: Union{Real, Int} = 0,\n            getTrials   :: Union{Bool, Vector{String}} = true, \n            stdClass    :: Bool = true, \n            msg         :: String=\"\",\n            # Arguments passed to encode\n            covtype = SCM,\n            targetLabel :: String = paradigm == :P300 ? \"target\" : nothing,\n            overlapping :: Bool = false,\n            weights = :a,\n            pcadim      :: Int = 8,\n            standardize :: Bool = false,\n            tikh        :: Union{Real, Int} = 0,\n            useBLAS     :: Bool = true,\n            reg         :: Symbol = :rmt,\n            tol         :: Real = 1e-6,\n            maxiter     :: Int = 200,\n            # Arguments passed to crval\n            pipeline    :: Union{Pipeline, Nothing} = nothing,\n            nFolds      :: Int     = 8,\n            shuffle     :: Bool    = false,\n            scoring     :: Symbol  = :b,\n            hypTest     :: Union{Symbol, Nothing} = :Bayle,\n            outModels   :: Bool    = false,\n            fitArgs...)\n\nRun in sequence the following three functions\n\nEegle.InOut.readNY\nencode (from this module)\ncrval\n\nThis allows to perform any supported types of cross-validations for a whatever BCI session in NY format.\n\nArguments\n\nfilename: the complete path of either the .npz or the .yml file of the recording to be used\nparadigm: any supported BCI paradigm, either :ERP, :P300, or :MI\nmodel : any classifier of type MLmodel. Default: the default MDM classifier.\n\nOptional Keyword Arguments\n\nA reminder only is given here. For details, see the function each kwarg is passed to.\n\nThe following are passed to Eegle.InOut.readNY for reading and pre-processing the data: \ntoFloat64: conversion of data to Float64\nbandStop, bandPass, bsDesign, bpDesign: (filter settings)\nrate: resampling\nupperLimit: artifact rejection\ngetTrials: classes to be read from the file\nstdClass: standardization of class labels according to Eegle's conventions\nmsg: meassage to be printed once the data has been read.\nthe following are passed to encode to encode the trials as covariance matrices: \ncovtype: type of covariance matrix estimation \ntargetLabel: label of the target class (for the P300 paradigm only). Default: target \noverlapping: type of mean target ERP estimator used as a prototype (ERP and P300 only)\nweights: whether to use an adaptive weighted mean target ERP estimation (ERP and P300 only)\npcadim: whether to reduce the dimension of the prototype by PCA (ERP and P300 only)\nstandardize: whether to standardize the trials before estimating the covariance matrices\ntikh: whether to apply a Tikhonov regularization to the covariance matrices\nuseBLAS: whether to use BLAS for computing the SCM covariance estimator\nreg: , tol, maxiter, verbose: options for covariance M-Estimators.\nthe following are passed to crval:    pipeline: pre-conditioners for hastening the computations   nFolds: number of cross-validation stratified folds (default: 8)   shuffle: how the folds are generated   scoring: performance index to be computed   hypTest: statistical test of the performance against the chance level   outModels: modulate the output   fitArgs...: additional arguments handed to the fit function of the model.\nthe following are passed to both encode and crval:       verbose: print informations about some computations       threaded: run the functions in multithreaded mode (in crval it is named with unice character ⏩).\n\nnote: `nFolds`\nThe default for all these kwargs are the same as in the functions they are passed to, except nFolds (the number of startified folds for the cross-validation), which default, differently from crval in PosDefManifoldML.jl, is 8.\n\ntip: `fitArgs...`\nFunction crval hands any additional kwargs to the fit function of the model. See crval for details. If you pass an invalid arguments, an error will be raised.\n\nReturn If outModels is false (default), a CVres structure  with the results of the cross-validation, otherwise a 2-tuple holding this CVres structure and a vector of the nFolds models fitted for each fold.\n\nExamples\n\n# Using the example files provided by Eegle\ncrval(EXAMPLE_P300_1, :P300)\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"documents/BCI Databases Overview/#BCI-Databases-Overview","page":"BCI DBs Overview","title":"BCI Databases Overview","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"This document outlines the structure and content of the 'BCI Databases' repository, which encompasses multiple datasets across various paradigms. Currently, it focuses on P300 and Motor Imagery (MI) data.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"<!– future sections to add when available:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Cleared data\ndeprecated data\nGitHub repository –>","category":"page"},{"location":"documents/BCI Databases Overview/#Terminology","page":"BCI DBs Overview","title":"Terminology","text":"","category":"section"},{"location":"documents/BCI Databases Overview/#BCI-paradigm","page":"BCI DBs Overview","title":"BCI paradigm","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It is a kind of BCI exploiting a specific electrophysiological phenomenon in order to achieve decoding of EEG data. ","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"The most widespread paradigms are MI, P300 and SSVEP. The experimental conditions under which a BCI may run within the same paradigm may be substantially different, contributing in promoting the variability of BCI data. For example, in MI trial duration and instructions given to the subject are diverse and so are in P300 the inter-stimulus interval, the flash duration, the number of flashing items, their meaning, etc. The number, position and type of electrodes, the EEG amplifier, the experimental procedure, environmental factors and subjects (e.g., healthy vs. unhealthy) are all confounding factors in BCI data.","category":"page"},{"location":"documents/BCI Databases Overview/#BCI-trial","page":"BCI DBs Overview","title":"BCI trial","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It is an EEG epoch (time interval) providing the elementary object of encoding and decoding approaches. These epochs are in general positioned in time relative to a stimulation or a cue, depending on the BCI paradigm, but may also be unrelated to any specific time position (e.g., in neurofeedback and self-paced MI). Typically, the duration of the trials is fixed in a given experiment and may last from a few hundred milliseconds to a few seconds.","category":"page"},{"location":"documents/BCI Databases Overview/#run","page":"BCI DBs Overview","title":"run","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"A collection of trials forms a run, which encompasses the time period during which an experimental subject is engaged in a task without interruption. Typically, a run lasts from a few minutes to a few tens of minutes.","category":"page"},{"location":"documents/BCI Databases Overview/#session","page":"BCI DBs Overview","title":"session","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It comprises all runs performed while EEG electrodes remain attached to a subject's head. A session may include one or more runs, with possible pauses in between them. EEG recording files typically enclose a session. In any case, in this documentation it is assumed so. A session typically lasts a few tens of minutes to a few hours.","category":"page"},{"location":"documents/BCI Databases Overview/#subject","page":"BCI DBs Overview","title":"subject","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It is a unique individual performing an experiment. A subject may provide one or several sessions. When several sessions are recorded from the same subject, they are typically recorded on different days.","category":"page"},{"location":"documents/BCI Databases Overview/#dataset","page":"BCI DBs Overview","title":"dataset","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It is an EEG recording, typically comprising a whole session. In this documentation the term dataset will not be used as it will always be synonymous with session.","category":"page"},{"location":"documents/BCI Databases Overview/#database","page":"BCI DBs Overview","title":"database","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"It is a collection of datasets recorded under experimental conditions held as constant as possible on one or more subjects. ","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Typically, the number of datasets corresponds to the number of sessions and this number does not need to match the number of unique subjects, that is, the number of sessions per subject may be different. We require that all sessions in a database have at least the following experimental parameters held constant: number of classes, trial duration, number of electrodes, type of electrodes, EEG amplifier. The interface should also be fixed as well as paradigm-specific experimental parameters, such as inter-stimulus interval and flash duration for P300, experimental instructions for MI, etc. Since in general experiments are run to manipulate experimental conditions, a single experiment will typically result in as many databases as experimental conditions. From a statistical point of view, these precautions make the sessions within the same database as homogeneous as possible, allowing to consider the accuracy achieved in those sessions as random samples drawn from the same population. This is important if any conclusions are to be drawn comparing the accuracy results between databases, e.g., between experimental conditions, and also if the databases are treated as observation units in comparing pipelines, as it is currently done in MOABB[1].","category":"page"},{"location":"documents/BCI Databases Overview/#Databases-Selection","page":"BCI DBs Overview","title":"Databases Selection","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Based on the terminology section, we have selected and separated multiple databases primarily acquired from MOABB[1] and supplemented by databases from their original repositories. Currently, our collection includes only P300 and Motor Imagery (MI) databases. This work was originally conducted for heterogeneous transfer learning research with the goal of \"universalizing\" BCI Databases, which guided our selection criteria. However, all data can be used for any purpose. For all paradigms, we have only included databases with healthy subjects.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Motor Imagery databases contain various classes, sometimes including paradigm-specific movements (e.g., compound movements). We selected only databases that included at least two of these following standard classes: ","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"left_hand → 1, right_hand → 2, feet → 3, rest → 4, both_hands → 5, tongue → 6","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Other classes were excluded. Additionally, databases containing executed movements or mental tasks (rather than imagined movements) were also excluded.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"P300 databases contain only two classes: ","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"\"nontarget\" → 1, \"target\" → 2. ","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"These classes must maintain a specific ratio for optimal P300 response elicitation: typically 5:1 (nontarget:target). This imbalanced ratio is essential for the oddball paradigm, as the infrequent target stimuli generate the characteristic P300 event-related potential. Databases where the ratio was lower or higher than 5:1 were excluded.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Here is an exhaustive list of our selected databases:","category":"page"},{"location":"documents/BCI Databases Overview/#Sixteen-Motor-Imagery-databases","page":"BCI DBs Overview","title":"Sixteen Motor Imagery databases","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"AlexMI[2]\nBNCI2014001[3]\nBNCI2014002[4]: separated into 2 different databases (BNCI2014002-Train and BNCI2014002-Test) due to different experimental conditions\nBNCI2014004[5]: separated into 2 different databases (BNCI2014004-Train and BNCI2014004-Test) due to different experimental conditions\nBNCI2015001[6]\nCho2017[7]\nGrossWentrup2009[8]\nLee2019MI[9]\nPhysionetMI[10]: separated into 2 different databases (PhysionetMI-T2 and PhysionetMI-T4) due to different experimental conditions\nSchirrmeister2017[11]\nShin2017A[12]\nWeibo2014[13]\nZhou2016[14]","category":"page"},{"location":"documents/BCI Databases Overview/#Twenty-Four-P300-databases","page":"BCI DBs Overview","title":"Twenty-Four P300 databases","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"bi2012[15]: separated into 2 different databases (bi2012-Training and bi2012-Online) due to different experimental conditions\nbi2013a[16]: separated into 4 different databases (bi2013a-NAO, bi2013a-NAT, bi2013a-AO, and bi2013a-AT) due to different experimental conditions\nbi2014a[17]\nbi2014b[18]\nbi2015a[19]: separated into 3 different databases (bi2015-1, bi2015a-2, and bi2015a-3) due to different experimental conditions\nBNCI2014009[20]\nBNCI2015003[21]: separated into 2 different databases (BNCI2015003-Train and BNCI2015003-Test) due to different experimental conditions\nCattan2019[22]: separated into 2 different databases (Cattan2019-PC and Cattan2019-VR) due to different experimental conditions\nEPFLP300[23]: separated into 6 different databases (EPFLP300-1, EPFLP300-2, EPFLP300-3, EPFLP300-4, EPFLP300-5, and EPFLP300-6) due to different experimental conditions\nLee2019ERP[9]: separated into 2 different databases (Lee2019ERP-Test and Lee2019ERP-Train) due to different experimental conditions","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"You can find summary tables of databases for each paradigm in here : P300 / MI.","category":"page"},{"location":"documents/BCI Databases Overview/#Repository-Structure","page":"BCI DBs Overview","title":"Repository Structure","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"The BCI Databases repository is organized into two main folders: 'CSV' and 'NY'. It also contains two other Markdown files related to the treatments applied to databases: TreatmentMI and TreatmentP300. The repository includes summary tables for each paradigm comprising all main characteristics of all databases.","category":"page"},{"location":"documents/BCI Databases Overview/#CSV-format","page":"BCI DBs Overview","title":"CSV format","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"The goal with the CSV format is to universalize the raw data of each database and establish a common structure format. The CSV files are organized as follows:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"First column: timestamps of the samples\nMiddle columns: EEG electrodes data\nLast column: stimulation containing labels for each class when an event is triggered\nLines correspond to samples of the acquired data.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Here are the common treatments applied to all databases:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Data is stored in Volts and Float64 format (to facilitate use with MNE Python[24], which only supports data in Volt)\nClasses were re-labeled to match the standardized numbering scheme described in the Databases Selection section\nData with sampling rates below 256 Hz was kept unchanged, while data above 256 Hz was downsampled using integer decimation factors to obtain integer sampling rates ≤ 256 Hz. For downsampling, we applied a zero-phase low-pass filter before decimation using MNE Python[24], with cutoff frequency less than 1/3 of the desired sampling rate to prevent aliasing artifacts (e.g., original sampling rate 1000 Hz, desired sampling rate 200 Hz → low-pass filter cutoff <66 Hz before applying decimation factor of 5).\nIrrelevant electrodes were removed (reference or ground electrodes, EMG and EOG electrodes)\nData from different runs within the same session with identical experimental conditions were concatenated into a single session file\nIrrelevant classes were removed (their labels were changed to 0)\nSamples where the sum of all EEG columns equaled 0 or that contained NaN values were removed (such artifacts never coincided with trigger events in the stimulation column and were found at the beginning or end of recordings)","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Stimulation column labeling was specific to the BCI paradigm:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"MI was labeled as \"left\\hand\" → 1, \"right\\hand\" → 2, \"feet\" → 3, \"rest\" → 4, \"both\\_hands\" → 5, \"tongue\" → 6\nP300 was labeled as \"nontarget\" → 1, \"target\" → 2\nRemaining samples were labeled as 0","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"Once all databases were converted to the CSV format, they were transcribed to NY format.","category":"page"},{"location":"documents/BCI Databases Overview/#NY-format","page":"BCI DBs Overview","title":"NY format","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"This format is tailor-made for BCI data, ensuring compatibility and ease of use in both Julia and Python environments.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"When converted to NY format, the EEG signal is stored in microvolts (µV) as it is the standard in the EEG community.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"The NY format consists of two essential files:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":".npz File: Contains the raw data and stimulation vector, crucial for BCI data analysis. This .npz file follows the standard NumPy[25] compressed archive format, which stores multiple arrays in a single file using ZIP compression. The file contains two arrays:\nX: EEG data matrix of shape (nsamples, nchannels) in µV and Float32 format\nstim: Stimulation vector of shape (n_samples,) with integer labels\nThis format is natively supported in Python through NumPy and easily readable in Julia via the NPZ.jl package.\n.yml File: Stores metadata offering a comprehensive overview of the dataset's characteristics. The dictionary structure can be viewed in detail here: YAML Structure","category":"page"},{"location":"documents/BCI Databases Overview/#Converters","page":"BCI DBs Overview","title":"Converters","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"All scripts designed for data conversion between formats (Base repository/MOABB to CSV and CSV to NY) tailored to each dataset's requirements are available in the 'Converters' folder and in GitHub repository.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"These scripts facilitate the data pre-processing workflow:","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"MOABB/BASE to CSV: Python scripts with comprehensive comments guide the users through the conversion process from downloaded raw data (MOABB or original repositories) to the defined CSV format\nCSV to NY: Python scripts with comprehensive comments guide the users through the conversion process from CSV to NY format.","category":"page"},{"location":"documents/BCI Databases Overview/#BCI-DB-References","page":"BCI DBs Overview","title":"BCI DB References","text":"","category":"section"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[1]: Aristimunha, B., Carrara, I., Guetschel, P., Sedlar, S., Rodrigues, P., Sosulski, J., Narayanan, D., Bjareholt, E., Quentin, B., Schirrmeister, R. T.,Kalunga, E., Darmet, L., Gregoire, C., Abdul Hussain, A., Gatti, R., Goncharenko, V., Thielen, J., Moreau, T., Roy, Y., Jayaram, V., Barachant,A., & Chevallier, S. Mother of all BCI Benchmarks (MOABB), 2023. DOI: 10.5281/zenodo.10034223.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[2]: Barachant, A., 2012. Commande robuste d'un effecteur par une interface cerveau machine EEG asynchrone (Doctoral dissertation, Université de Grenoble): https://tel.archives-ouvertes.fr/tel-01196752","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[3]: Tangermann, M., Müller, K.R., Aertsen, A., Birbaumer, N., Braun, C., Brunner, C., Leeb, R., Mehring, C., Miller, K.J., Mueller-Putz, G. and Nolte, G., 2012. Review of the BCI competition IV. Frontiers in neuroscience, 6, p.55.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[4]: Steyrl, D., Scherer, R., Faller, J. and Müller-Putz, G.R., 2016. Random forests in non-invasive sensorimotor rhythm brain-computer interfaces: a practical and convenient non-linear classifier. Biomedical Engineering/Biomedizinische Technique, 61(1), pp.77-86.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[5]: R. Leeb, F. Lee, C. Keinrath, R. Scherer, H. Bischof, G. Pfurtscheller. Brain-computer communication: motivation, aim, and impact of exploring a virtual apartment. IEEE Transactions on Neural Systems and Rehabilitation Engineering 15, 473–482, 2007","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[6]: J. Faller, C. Vidaurre, T. Solis-Escalante, C. Neuper and R. Scherer (2012). Autocalibration and recurrent adaptation: Towards a plug and play online ERD- BCI. IEEE Transactions on Neural Systems and Rehabilitation Engineering, 20(3), 313-319.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[7]: Cho, H., Ahn, M., Ahn, S., Kwon, M. and Jun, S.C., 2017. EEG datasets for motor imagery brain computer interface. GigaScience. https://doi.org/10.1093/gigascience/gix034","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[8]: Grosse-Wentrup, Moritz, et al. \"Beamforming in noninvasive brain–computer interfaces.\" IEEE Transactions on Biomedical Engineering 56.4 (2009): 1209-1219.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[9]: Lee, M. H., Kwon, O. Y., Kim, Y. J., Kim, H. K., Lee, Y. E., Williamson, J., … Lee, S. W. (2019). EEG dataset and OpenBMI toolbox for three BCI paradigms: An investigation into BCI illiteracy. GigaScience, 8(5), 1–16. https://doi.org/10.1093/gigascience/giz002","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[10]: Goldberger, A.L., Amaral, L.A., Glass, L., Hausdorff, J.M., Ivanov, P.C., Mark, R.G., Mietus, J.E., Moody, G.B., Peng, C.K., Stanley, H.E. and PhysioBank, P., PhysioNet: components of a new research resource for complex physiologic signals Circulation 2000 Volume 101 Issue 23 pp. E215–E220.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[11]: Schirrmeister, Robin Tibor, et al. \"Deep learning with convolutional neural networks for EEG decoding and visualization.\" Human brain mapping 38.11 (2017): 5391-5420.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[12]: Shin, J., von Lühmann, A., Blankertz, B., Kim, D.W., Jeong, J., Hwang, H.J. and Müller, K.R., 2017. Open access dataset for EEG+NIRS single-trial classification. IEEE Transactions on Neural Systems and Rehabilitation Engineering, 25(10), pp.1735-1745.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[13]: Yi, Weibo, et al. \"Evaluation of EEG oscillatory patterns and cognitive process during simple and compound limb motor imagery.\" PloS one 9.12 (2014). https://doi.org/10.1371/journal.pone.0114853","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[14]: Zhou B, Wu X, Lv Z, Zhang L, Guo X (2016) A Fully Automated Trial Selection Method for Optimization of Motor Imagery Based Brain-Computer Interface. PLoS ONE 11(9). https://doi.org/10.1371/journal.pone.0162657","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[15]: Van Veen, G., Barachant, A., Andreev, A., Cattan, G., Rodrigues, P. C., & Congedo, M. (2019). Building Brain Invaders: EEG data of an experimental validation. arXiv preprint arXiv:1905.05182.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[16]: Vaineau, E., Barachant, A., Andreev, A., Rodrigues, P. C., Cattan, G. & Congedo, M. (2019). Brain invaders adaptive versus non-adaptive P300 brain-computer interface dataset. arXiv preprint arXiv:1904.09111.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[17]: Korczowski, L., Ostaschenko, E., Andreev, A., Cattan, G., Rodrigues, P. L. C., Gautheret, V., & Congedo, M. (2019). Brain Invaders calibration-less P300-based BCI using dry EEG electrodes Dataset (BI2014a). https://hal.archives-ouvertes.fr/hal-02171575","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[18]: Korczowski, L., Ostaschenko, E., Andreev, A., Cattan, G., Rodrigues, P. L. C., Gautheret, V., & Congedo, M. (2019). Brain Invaders Solo versus Collaboration: Multi-User P300-Based Brain-Computer Interface Dataset (BI2014b). https://hal.archives-ouvertes.fr/hal-02173958","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[19]: Korczowski, L., Cederhout, M., Andreev, A., Cattan, G., Rodrigues, P. L. C., Gautheret, V., & Congedo, M. (2019). Brain Invaders calibration-less P300-based BCI with modulation of flash duration Dataset (BI2015a) https://hal.archives-ouvertes.fr/hal-02172347","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[20]: P Aricò, F Aloise, F Schettini, S Salinari, D Mattia and F Cincotti (2013). Influence of P300 latency jitter on event related potential- based brain–computer interface performance. Journal of Neural Engineering, vol. 11, number 3.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[21]: C. Guger, S. Daban, E. Sellers, C. Holzner, G. Krausz, R. Carabalona, F. Gramatica, and G. Edlinger (2009). How many people are able to control a P300-based brain-computer interface (BCI)?. Neuroscience Letters, vol. 462, pp. 94–98.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[22]: G. Cattan, A. Andreev, P. L. C. Rodrigues, and M. Congedo (2019). Dataset of an EEG-based BCI experiment in Virtual Reality and on a Personal Computer. Research Report, GIPSA-lab; IHMTEK. https://doi.org/10.5281/zenodo.2605204","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[23]: Hoffmann U, Vesin JM, Ebrahimi T, Diserens K. An efficient P300-based brain-computer interface for disabled subjects. J Neurosci Methods. 2008 Jan 15;167(1):115-25. doi: 10.1016/j.jneumeth.2007.03.005. Epub 2007 Mar 13. PMID: 17445904.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[24]: Alexandre Gramfort, Martin Luessi, Eric Larson, Denis A. Engemann, Daniel Strohmeier, Christian Brodbeck, Roman Goj, Mainak Jas, Teon Brooks, Lauri Parkkonen, and Matti S. Hämäläinen. MEG and EEG data analysis with MNE-Python. Frontiers in Neuroscience, 7(267):1–13, 2013. doi:10.3389/fnins.2013.00267.","category":"page"},{"location":"documents/BCI Databases Overview/","page":"BCI DBs Overview","title":"BCI DBs Overview","text":"[25]: Harris, C. R., Millman, K. J., van der Walt, S. J., Gommers, R., Virtanen, P., Cournapeau, D., … Oliphant, T. E. (2020). Array programming with NumPy. Nature, 585, 357–362. https://doi.org/10.1038/s41586-020-2649-2","category":"page"},{"location":"Database/#Database.jl","page":"Database","title":"Database.jl","text":"","category":"section"},{"location":"Database/","page":"Database","title":"Database","text":"This module implements tools to facilitate the work with EEG databases, in particular, BCI databases in NY format — see the BCI Databases Overview.","category":"page"},{"location":"Database/","page":"Database","title":"Database","text":"To learn how to use BCI databases, see Tutorial ML 1.","category":"page"},{"location":"Database/#Methods","page":"Database","title":"Methods","text":"","category":"section"},{"location":"Database/","page":"Database","title":"Database","text":"Function Description\nEegle.Database.infoDB immutable structure holding the information summarizing an EEG database\nEegle.Database.loadNYdb return a list of .npz files in a directory (this is considered a 'database')\nEegle.Database.infoNYdb print, save and return metadata about a database\nEegle.Database.selectDB select database folders based on paradigm and class requirements\nEegle.Database.weightsDB get weights for each session of a database for statistical analysis","category":"page"},{"location":"Database/","page":"Database","title":"Database","text":"📖","category":"page"},{"location":"Database/#Eegle.Database.infoDB","page":"Database","title":"Eegle.Database.infoDB","text":"struct infoDB\n    dbName              :: String\n    condition           :: String\n    paradigm            :: String\n    files               :: Vector{String}\n    nSessions           :: Vector{Int}\n    nTrials             :: Dict{String, Vector{Int}}\n    nSubjects           :: Int\n    nSensors            :: Int\n    sensors             :: Vector{String}\n    sensorType          :: String\n    nClasses            :: Int\n    cLabels             :: Vector{String}\n    sr                  :: Int\n    wl                  :: Int\n    offset              :: Int\n    filter              :: String\n    doi                 :: String\n    hardware            :: String\n    software            :: String\n    reference           :: String\n    ground              :: String\n    place               :: String\n    investigators       :: String\n    repository          :: String\n    description         :: String\n    timestamp           :: Int\n    formatVersion       :: String\nend\n\nImmutable structure holding the summary information and metadata of an EEG database (DB) in NY format.\n\nIt is created by the function infoNYdb.\n\nFields\n\n.files returns a list of .npz files, each corresponding to a session in the database. The length of .files equals the total number of sessions\n.nSessions: vector holding the number of sessions per subject\n.nTrials: a dictionary mapping each class label to a vector containing the number of trials per session for that class. For example, nTrials[\"left_hand\"] returns a vector with the number of trials for \"left_hand\" across all sessions.\n\nThe following fields are assumed constant across all recordings of the database. This is checked by Eegle when you read a database.\n\n.dbName: name or identifier of the database\n.condition: experimental condition under which the DB has been recorded\n.paradigm: for BCI data, this may be :P300, :ERP or :MI — see BCI paradigm\n.nSubjects: total number of subjects composing the DB — see subject\n.nSensors: number of sensors composing the recordings (e., g., EEG electrodes)\n.sensors: list of sensor labels (e.g., [Fz, Cz, ...,Oz])\n.sensorType: type of sensors (wet, dry, Ag/cl, ...)\n.nClasses: number of classes for which labels are available\n.cLabels: list of class labels\n.sr: sampling rate of the recordings (in samples)\n.wl: for BCI, this is the duration of trials (in samples)\n.offset: shift to be applied to markers in order to determine the trial onset (in samples)\n.filter: temporal filter that has been applied to the data\n.hardware: equipment used to obtain the recordings (typically, the EEG amplifier)\n.software: software used to obtain the recordings\n.reference: label of the reference electrode for EEG differential amplifiers\n.ground: label of the electrical ground electrode\n.doi: digital object identifier (DOI) of the database\n.place: place where the recordings have been obtained\n.investigators: investigator(s) that have obtained the recordings\n.repository: public repository where the DB has made accessible\n.description: general description of the DB\n.timestamp: date of the publication of the DB\n.formatVersion: version of the NY format in which the recordings have been stored.\n\n\n\n\n\n","category":"type"},{"location":"Database/#Eegle.Database.loadNYdb","page":"Database","title":"Eegle.Database.loadNYdb","text":"    function loadNYdb(dbDir=AbstractString, isin::String=\"\")\n\nReturn a list of the complete paths of all .npz files found in a directory given as argument dbDir. For each NPZ file, there must be a corresponding YAML metadata file with the same name and extension .yml, otherwise the file is not included in the list.\n\nIf a string is provided as kwarg isin, only the files whose name contains the string will be included. \n\nSee Also \n\ninfoNYdb, FileSystem.getFilesInDir\n\nExamples xxx\n\n\n\n\n\n","category":"function"},{"location":"Database/#Eegle.Database.infoNYdb","page":"Database","title":"Eegle.Database.infoNYdb","text":"    function infoNYdb(dbDir)\n\nCreate a infoDB structure and show it in Julia's REPL.\n\nThe only argument (dbDir) is the directory holding all files of a database — see NY format.\n\nThis function carry out a sanity checks on the database and prints warnings if the checks fail.\n\nExamples\n\ndb = infoNYdb(dbDir)\n\n\n\n\n\n","category":"function"},{"location":"Database/#Eegle.Database.selectDB","page":"Database","title":"Eegle.Database.selectDB","text":"    function selectDB(rootDir       :: String, \n                    paradigm      :: Symbol;\n                    classes       :: Union{Vector{String}, Nothing} = nothing,\n                    minTrials     :: Union{Int, Nothing} = nothing,\n                    summary       :: Bool = true)\n\nReturn a list of infoDB structures for all databases found in directory rootDir. Databases are selected according to the provided paradigm, which must be :P300, :ERP or :MI. \n\nIf classes is provided as a vector of class labels, return only the databases featuring those class labels. P300 databases always features only two classes (\"target\" and \"nontarget\").  Typical MI class labels are: \"left_hand\", \"right_hand\", \"feet\", \"rest\", \"both_hands\", and \"tongue\".\n\nIf minTrials is provided as an integer, return for each database only the sessions featuring at least this number of trials in each class.\n\nIf summary is true (default), print a summary table of the selected databases.\n\nExamples\n\nselectedDB = selectDB(.../directory_to_start_searching/, :P300)\n\nselectedDB = selectDB(.../directory_to_start_searching/, :MI;\n                      classes=[\"left_hand\", \"right_hand\"])\n\nselectedDB = selectDB(.../directory_to_start_searching/, :MI;\n                      classes=[\"rest\", \"both_hands\", \"feet\"],\n                      minTrials=50,\n                      summarize=false)\n\n\n\n\n\n","category":"function"},{"location":"Database/#Eegle.Database.weightsDB","page":"Database","title":"Eegle.Database.weightsDB","text":"    function weightsDB(files)\n\nGiven a database provided by argument files as a list of .npz files,  compute a weight for each session to be used in statistical analysis when merging the classification performance  or any other relevant index across databases. \n\nThe goal of the weighting is to balance the contribution of different databases  and the different subjects therein, considering both the number of unique subjects in each database and the fact that the number of session for each subject may be different.\n\nThe weight assigned to each session is inversely proportional to the square root of the number of unique subjects  in the database and to the square root of the number of sessions available for the same subject.\n\nLet s_m be one of the S_m sessions for each unique subject m, the weight w_ms_m for session s_m is given by:\n\n    w_ms_m = fracsqrtM cdot sqrtS_mN\n\nwhere M is the number of unique subjects in the database and N is the total number of sessions (i.e., length(files)).\n\nThis weighting ensures that the sum of the weights for each subject is proportional to\n\nsqrtM cdot sqrtS_m\n\nFor example,\n\nif the database has M = 100 subjects and each has 1 session, the  total weight for each subject is sqrt100 cdot sum_m=1^100 fracsqrt1N = 10\nif each of the 100 subjects has 4 sessions, the total weight for each subject is sqrt100 cdot sum_m=1^100 fracsqrt4N = 20.\n\nThis is a compromise between two extreme strategies commonly used when merging indices across databases, which are both inadequate:\n\nUniform per-session weights (i.e., all sessions contribute equally), which favors larger databases or those with many sessions\nUniform per-database weights (i.e., all databases contribute equally), which overemphasizes small databases.\n\nOnce obtained the weights for several databases, they can be globally normalized in any desired way.\n\nReturn\n\nweights: a vector of length N, containing the weight for each session in files\nschedule: an N  2 matrix of integers where:\nthe first column contains the index of the subject to which the session belongs\nthe second column contains the number of sessions for that subject.\n\nExamples\n\nw, schedule = weightsDB(files)\n\nTutorials xxx\n\n\n\n\n\n","category":"function"},{"location":"Miscellaneous/#Miscellaneous.jl","page":"Miscellaneous","title":"Miscellaneous.jl","text":"","category":"section"},{"location":"Miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"This module implements miscellaneous utilities.","category":"page"},{"location":"Miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"Function Description\nEegle.Miscellaneous.remove remove elements from vectors and rows or columns from matrices\nEegle.Miscellaneous.isSquare check that a matrix is square\nEegle.Miscellaneous.minima local minuma of a sequence","category":"page"},{"location":"Miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"📖","category":"page"},{"location":"Miscellaneous/#Eegle.Miscellaneous.remove","page":"Miscellaneous","title":"Eegle.Miscellaneous.remove","text":"    function remove(X::Union{Vector, Matrix}, \n                    what::Union{Int, Vector{Int}}; \n        dims=1)\n\nReturn vector X removing one or more elements, or matrix X removing one or more columns or rows.\n\nIf X is a matrix, dims=1 (default) remove rows, dims=2 remove columns.\n\nIf X is a Vector, dims has no effect.\n\nThe what argument can be either an integer or a vector of integers\n\nSee Also Eegle.Preprocessing.removeSamples, Eegle.Preprocessing.removeChannels\n\nExamples\n\nusing Eegle # or using Eegle.Miscellaneous\n\na=randn(5)\nb=remove(a, 2) # remove second element\nb=remove(a, collect(1:3)) # remove rows 1 to 3\n\nA=randn(3, 3)\nB=remove(A, 2) # remove second row\nB=remove(A, 2; dims=2) # remove second column\n\nA=randn(5, 5)\nB=remove(A, collect(1:2:5)) # remove rows 1, 3 and 5\nC=remove(A, [1, 4]) # remove rows 1 and 4\n\nA=randn(10, 10)\nB=remove(A, [collect(2:3); collect(8:10)]; dims=2)\n# remove columns 2, 3, 8, 9, 10\n\nA=randn(10, 10)\nB=remove(A, collect(1:2:size(A, 1)); dims=1)\n# remove every other sample (decimation by a factor of 2)\n\n\n\n\n\n","category":"function"},{"location":"Miscellaneous/#Eegle.Miscellaneous.isSquare","page":"Miscellaneous","title":"Eegle.Miscellaneous.isSquare","text":"  function isSquare(X)\n\nReturn true if X is an AnyMatrix and is square, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Miscellaneous/#Eegle.Miscellaneous.minima","page":"Miscellaneous","title":"Eegle.Miscellaneous.minima","text":"    function minima(v::AbstractVector{T}) \n    where T<:Real\n\nReturn the 2-tuple formed by the vector of local minima of vector v and the vector of the indices of v corresponding to the minima.\n\nThis is useful in several situations. For example, Eegle uses it to segment spontaneous EEG data (see Eegle.Processing.epoching).\n\n\n\n\n\n","category":"function"},{"location":"documents/yamlstruct/#NY-Metadata-(YAML)","page":"NY metadata (YAML)","title":"NY Metadata (YAML)","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"This document describes the standard dictionary structure used in .yml metadata files for EEG time series data in the NY format.","category":"page"},{"location":"documents/yamlstruct/#Overview","page":"NY metadata (YAML)","title":"Overview","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"The YAML format has been employed for easily sharing EEG data metadata in Python and Julia environments. Each .yml file provides comprehensive metadata for its corresponding .npz data file.","category":"page"},{"location":"documents/yamlstruct/#Dictionary-Structure","page":"NY metadata (YAML)","title":"Dictionary Structure","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"The YAML file contains four main dictionaries:","category":"page"},{"location":"documents/yamlstruct/#acquisition","page":"NY metadata (YAML)","title":"acquisition","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Contains all technical information about the EEG data acquisition process.","category":"page"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Field Type Description Example\nfilter String Filter settings of the EEG acquisition machine \"Low-Pass 83Hz (Butterworth order 4 zero phase) for downsampling\"\nground String Location of the ground electrode \"Fpz\" or \"N/A\"\nreference String Location of the reference electrode \"A1\" or \"N/A\"\nhardware String Commercial name and producer of EEG amplifier \"g.tec EEG - g.USBamp EEG amplifier\"\nsoftware String Software used for data acquisition \"OpenViBE, INRIA (France)\" or \"N/A\"\nsamplingrate Integer Sampling rate in Hz 256\nsensors Array of Strings EEG electrode locations (excluding ground/reference) [\"Fpz\", \"F7\", \"F3\", \"Fz\", ...]\nsensortype String Type and material of electrodes \"Ag/AgCl Wet electrodes\"","category":"page"},{"location":"documents/yamlstruct/#documentation","page":"NY metadata (YAML)","title":"documentation","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Contains references and documentation links for the dataset.","category":"page"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Field Type Description Example\ndescription String Link to dataset description \"https://zenodo.org/records/806023\"\ndoi String Digital Object Identifier \"https://theses.hal.science/tel-01196752\"\ninvestigators String Principal investigators \"Alexandre Barachant\"\nplace String Institution where experiment was conducted \"GIPSA-lab...\"\nrepository String Link to data repository \"https://zenodo.org/records/806023\"","category":"page"},{"location":"documents/yamlstruct/#id","page":"NY metadata (YAML)","title":"id","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Contains identification information for the specific recording.","category":"page"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Field Type Description Example\ncondition String Experimental condition \"None\" or specific condition\ndatabase String Name of the database \"AlexMI\"\nparadigm String BCI paradigm type \"MI\" or \"P300\"\nrun Integer Run number within session 1\nsession Integer Session number 1\nsubject Integer Subject identifier 1\ntimestamp Integer Year of data collection 2012","category":"page"},{"location":"documents/yamlstruct/#stim","page":"NY metadata (YAML)","title":"stim","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Contains stimulation and labeling information.","category":"page"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"Field Type Description Example\nlabels Dictionary Mapping of class names to numeric codes {\"right_hand\": 2, \"feet\": 3, \"rest\": 4}\nnclasses Integer Total number of stimulus classes 3\ntrials_per_class Dictionary Number of trials available for each class {\"feet\": 20, \"rest\": 20, \"right_hand\": 20}\noffset Integer Offset in samples from stimulation to trial start 0\nwindowlength Integer Trial duration in samples 768","category":"page"},{"location":"documents/yamlstruct/#Example-Structure","page":"NY metadata (YAML)","title":"Example Structure","text":"","category":"section"},{"location":"documents/yamlstruct/","page":"NY metadata (YAML)","title":"NY metadata (YAML)","text":"formatversion: 0.0.1\n\nacquisition:\n  filter: \"Low-Pass 83Hz (Butterworth order 4 zero phase) for downsampling\"\n  ground: \"N/A\"\n  hardware: \"g.tec EEG - g.USBamp EEG amplifier\"\n  reference: \"N/A\"\n  samplingrate: 256\n  sensors: [\"Fpz\", \"F7\", \"F3\", \"Fz\", \"F4\", \"F8\", \"T7\", \"C3\", \"Cz\", \"C4\", \"T8\", \"P7\", \"P3\", \"Pz\", \"P4\", \"P8\"]\n  sensortype: \"Ag/AgCl Wet electrodes\"\n  software: \"N/A\"\n\ndocumentation:\n  description: \"https://zenodo.org/records/806023\"\n  doi: \"https://theses.hal.science/tel-01196752\"\n  investigators: \"Alexandre Barachant\"\n  place: \"Laboratoire Electronique et systeme pour la sante CEA-LETI dans l'Ecole Doctorale : EEATS, Universite de Grenoble\"\n  repository: \"https://zenodo.org/records/806023\"\n\nid:\n  condition: \"None\"\n  database: \"AlexMI\"\n  paradigm: \"MI\"\n  run: 1\n  session: 1\n  subject: 1\n  timestamp: 2012\n\nstim:\n  labels:\n    right_hand: 2\n    feet: 3\n    rest: 4\n  nclasses: 3\n  trials_per_class:\n    right_hand: 20\n    feet: 20\n    rest: 20\n  offset: 0\n  windowlength: 768","category":"page"},{"location":"ERPs/#ERPs.jl","page":"Event-Related Potentials","title":"ERPs.jl","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"This module implements basic tools fo the analysis of Event-Related Potentials (ERPs).  Many of these tolls are useful for working with tagged EEG data in general, for example, with BCI data.","category":"page"},{"location":"ERPs/#Extract-ERPs","page":"Event-Related Potentials","title":"Extract ERPs","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"ERPs are EEG potentials time and phase-locked to the presentation of sensory stimuli.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"They are extracted averaging EEG epochs (trials) of fixed duration starting at a fixed position in time with respect to the presentation of stimuli.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Eegle handles two ways to extract ERPs: using a stimulation vector or using marker vectors. You can swicth from one representation to the other using the stim2mark and mark2stim functions.","category":"page"},{"location":"ERPs/#stimulation-vector","page":"Event-Related Potentials","title":"stimulation vector","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"This is an accessory channel holding as many samples as there are in the EEG recording. The value is zero everywhere, except at samples corresponding to a stimulus presentation, where the value is a natural number (1, 2, ...), each one coding a stimulus class. We name these numbers the tag of each sample.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"# Toy example of a stimulation vector for two classes\n[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0]","category":"page"},{"location":"ERPs/#marker-vectors","page":"Event-Related Potentials","title":"marker vectors","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Equivalently, we can cosider a vector holding z vectors, each one listing the serial numbers of the samples belonging to each of the possible z classes.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"# Representation of the above stimulation vector as markers vector\n`[[13, 18], [6]]`","category":"page"},{"location":"ERPs/#offset","page":"Event-Related Potentials","title":"offset","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Several Eegle methods allow setting an offset to determine the starting sample of all evoked potentials (or trials). The offset is always to be given in samples. It can be ","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"zero (default): it does not affect the stimulations and corresponding markers, \nnegative: the stimulations and markers are shifted back,\npositive: the stimulations and markers are shifted forth.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"# Example with `offet=-3`; the above stimulation vector and marker vectors becomes\n[0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]\n[[10, 15], [3]]","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"warning: Data in NY format\nWhen data in NY format is read, the offset is applied and reset to zero — see readNY.","category":"page"},{"location":"ERPs/#overlapping","page":"Event-Related Potentials","title":"overlapping","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"The ERPs are said overlapping if the minimum inter-stimulus interval is shorter than the ERP window length, that is, if a stimulus can be presented before the preceeding evoked response has ended. In this situation, the multivariate regression (MR) method can provide better ERP estimates as compared  to the standard arithmetic average (AE) (Congedo et al., 2016).","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Methods estimating ERPs in Eegle feature the overlapping boolean kwarg, by which you can switch between the AE (false) and MR method (true).","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"note: Overlapping\nIf the ERPs are overlapping and you set overlapping to true, all means should be estimated at once; In fact, the advantage of the MR method vanishes if the means are computed individually. In general, do not set overlapping to true for computing only one mean, even if the stumulations are overlapping. In this case the AE and MR methods are equivalent, but the AE is faster and more accurate.For the same reason, do not set overlapping to true if the ERPs do not actually overlap.","category":"page"},{"location":"ERPs/#Resources-for-ERPs","page":"Event-Related Potentials","title":"Resources for ERPs","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"For classifying ERPs using Riemannian geometry — see package PosDefManifoldML.jl.","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"For spatial filters increasing the signal-to-noise ratio of ERPs — see the CSP and CSTP functions in package Diagonalizations.jl and article (Congedo et al., 2016).","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"For the analysis of time-locked and phase-locked components of ERPs, as well as ERP synchronization measures, in the time-frequency domain — see package FourierAnalysis.jl and companion article (Congedo, 2018).","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Unfold is a package dedicated to ERP analysis.","category":"page"},{"location":"ERPs/#Methods","page":"Event-Related Potentials","title":"Methods","text":"","category":"section"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"Function Description\nEegle.ERPs.mean compute ERPs from an EEG recording (2 methods)\nEegle.ERPs.stim2mark convert a stimulation vector into marker vectors\nEegle.ERPs.mark2stim convert marker vectors into a stimulation vector\nEegle.ERPs.merge merge and reorganize marker vectors\nEegle.ERPs.trialsWeights compute adaptive weights for average ERP estimations\nEegle.ERPs.trials extract trials (e.g., ERPs) from a  tagged EEG recording\nEegle.ERPs.reject reject trials (e.g., ERPs) in a tagged EEG recording","category":"page"},{"location":"ERPs/","page":"Event-Related Potentials","title":"Event-Related Potentials","text":"📖","category":"page"},{"location":"ERPs/#Statistics.mean","page":"Event-Related Potentials","title":"Statistics.mean","text":"(1) function mean(  X::Matrix{T}, \n                    wl::S, \n                    mark::Vector{Vector{S}};\n        overlapping :: Bool = false,\n        offset :: S = 0,\n        weights :: Union{Vector{Vector{R}}, Symbol}=:none) \n    where {T<:Real, S<:Int}\n\n(2) function mean(  o::EEG; \n        overlapping :: Bool = false,\n        offset :: S = 0,\n        weights :: Union{Vector{Vector{T}}, Symbol} = :none,\n        mark :: Union{Vector{Vector{S}}, Nothing} = nothing) \n    where {T<:Real, S<:Int}\n\nEstimate the weighted mean ERPs (event-related potentials), as the standard arithmetic mean (default)  or using the multivariate regression method, as detailed in (Congedo et al., 2016).\n\nTutorials\n\nxxx\n\nMETHOD (1)\n\nArguments\n\nX: the whole EEG recording, a matrix of size TN, where T and N denotes the number of samples and channels (sensors), respectively\nwl: the window (trial or ERP) length in samples\nmark: the marker vectors.\n\nwarning: Empty markers vectors\nIf mark holds empty vectors, they will be ignored and the mean will not be computed for those marks. The number of means therefore will be equal to the number of non-empty mark vectors.\n\nOptional Keyword Arguments\n\noverlapping: see overlapping\noffset: see offset\nweights: can be used to obtain weighted means. By default, equal weights are used. It can be: \na vector of vectors of non-negative real weights for the trials, with the same shape as mark, where the empty vectors of mark are ignored\n:a : adaptive weights computed as the inverse of the squared Frobenius norm of the trials data, along the lines of (Congedo et al., 2016).\n\nwarning: offset\nIf mark has been created using an offset when reading the data using Eegle.InOut.readNY, set offset to zero here.Markers which value plus the offset exceeds t minus the window length will be ignored, as they cannot define a complete ERP (or trial).\n\nReturn\n\nA vector of mean ERPs, one for each non-empty vectors in mark. Each mean is a matrix of size  wln, where n is the number of electrodes.\n\nMETHOD (2) \n\nThe same as method (1), but taking as input an Eegle.InOut.EEG structure o, which has fields providing the recording (X), the ERP duration in samples (wl) and the markers (mark).\n\nDifferent markers can be used instead by passing marker vectors with the mark kwarg.\n\nSee Eegle.ERPs.stim2mark, Eegle.ERPs.trialsWeights\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\n\n# Method (1)\n\n# Number of channels, sampling rate and window length\nN, sr, wl = 19, 128, 128\n\n# number of tags per class\nnm=[30, 45, 28]\n\nX=randn(sr*100, N)\nmark=[[rand(1:sr*100-wl) for i=1:m] for m∈nm]\n\n# compute the means for all classes with adaptive weighting\n𝐌=mean(X, wl, mark; overlapping=true, weights=:a)\n\n# compute the means for class 1 and 3\n𝐌=mean(X, wl, [mark[1], mark[3]]; overlapping=true)\n\n# compute the mean  with adaptive weighting only for the first class\n# and return it as a matrix (not as a vector of matrices)\nM=mean(X, wl, [mark[1]]; weights=:a)[1]\n\n# Method (2)\n# xxx Load a NY file\n𝐌=mean(o; overlapping=true, weights=:a)\n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Eegle.ERPs.stim2mark","page":"Event-Related Potentials","title":"Eegle.ERPs.stim2mark","text":"    function stim2mark( stim::Vector{S}, \n                        wl::S;\n        offset::S=0, code=nothing) \n    where S <: Int\n\nConvert a stimulation vector into marker vectors.\n\nArguments\n\nstim: the stimulation vector to be converted\nwl: the window (trial or ERP) length in samples.\n\nOptional Keyword Arguments\n\ncode: by default, the output will hold as many marker vectors as the largest tag (integers) in stim,   which may or may not hold instances of all integers up to the largest.   If there are missing integers, the corresponding marker vector will be empty.   Alternatively, a vector of tags coding the classes of stimulations in stim can be passed as    kwarg code. In this case, arbitrary non-zero tags can be used (even negative)   and the number of marker vectors will be equal to the number of   unique integers in code. If code is provided, the marker vectors are arranged in the order given there,   otherwise the first vector corresponds to the tag 1, the second to tag 2, etc.   In ant case, in each vector, the samples are sorted in ascending order.\n\nwarning: offset\nMarkers which value plus the offset is non-positive or exceeds the length of stim minus wl will be ignored, as they cannot define a complete ERP (or trial). If this happens, passing the output to mark2stim will not return stim back exactly. Actually, calling this function and reverting the operation with mark2stim ensures that the  stimulation vector is valid.\n\nReturn\n\nA vector of z marker vectors, where z is the number of classes, i.e., the highest integer in stim or the number of non-zero elements in code if it is provided.\n\nSee mark2stim\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\n\nsr, wl = 128, 256 # sampling rate, window length of trials\nns = sr*100 # number of samples of the recording\n\n# simulate a valid stimulations vector for three classes\nstim = vcat([rand()<0.01 ? rand(1:3) : 0 for i = 1:ns-wl], zeros(Int, wl))\n\nmark = stim2mark(stim, wl)\n\nstim2 = mark2stim(mark, ns) # is identical to stim\n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Eegle.ERPs.mark2stim","page":"Event-Related Potentials","title":"Eegle.ERPs.mark2stim","text":"    function mark2stim( mark::Vector{Vector{S}}, \n                        ns::S;\n        offset::S=0, code=nothing) \n    where S <: Int\n\nReverse transformation of stim2mark.\n\nnote: Note\nIf an offset has been used in stim2mark, -offset must be used here in order to get back to the original stimulation vector.\n\nIf code is provided, it must not contain 0. \n\nExamples see stim2mark\n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Base.merge","page":"Event-Related Potentials","title":"Base.merge","text":"    function merge( mark::Vector{Vector{S}}, \n                    mergeClasses::Vector{Vector{S}})\n    where S <: Int\n\nMerge the vectors of marker vectors mark and sort the markers within each class. Return another marker vectors. The merging pattern is determined by mergeClasses.\n\nAs an example, suppose mark holds 4 vectors of markers and mergeClasses=[[1, 2], [3, 4]], then the result will hold two markers vectors, vectors 1 and 2 of mark concatenated and sorted and vectors 3 and 4 of in mark concatenated and sorted. Empty mark vectors will be ignored.\n\nThis can be used to merge classes in ERP and BCI experiments.\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\nmark =  [   [128, 367], \n            [245, 765, 986],\n            [467, 880, 1025, 1456],\n            [728, 1230, 1330, 1550, 1980],  \n        ]\n\nmerged = merge(mark, [[1, 2], [3, 4]])\n\n# return: 2-element Vector{Vector{Int64}}:\n#           [128, 245, 367, 765, 986]\n#           [467, 728, 880, 1025, 1230, 1330, 1456, 1550, 1980]\n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Eegle.ERPs.trials","page":"Event-Related Potentials","title":"Eegle.ERPs.trials","text":"    function trials(X::Matrix{R}, \n                    stimOrMark::Union{Vector{S}, Vector{Vector{S}}}, \n                    wl::S;\n        shape::Symbol = :cat\n        weights::Union{Vector{R}, Nothing} = nothing,\n        linComb::Union{Vector{R}, S, Nothing} = nothing,\n        offset::S = 0) \n    where {R<:Real, S<:Int}\n\n\nExtract trials of duration wl from a tagged EEG recording X. Optionally, multiply them by weights and compute a linear combination across sensors thereof.\n\ntip: Tip\nTo extract trials and compute their mean, see mean; for segmenting non-tagged data, see Eegle.Processing.epoching.\n\nArguments\n\nX: the whole EEG recording, a matrix of size TN, where T is the number of samples and N the number of channels (sensors).\nstimOrMark: either a stimulation vector or marker vectors. \nwl: the window (trial, e.g., ERP) length in samples.\n\nOptional Keyword Arguments\n\nshape: see below.\nweights: optional weights to be multiplied to the trials. It has the same size as stimOrMark. Adaptive weights can be obtained passing the Eegle.ERPs.trialsWeights function.\n\nwarning: Weights normalization\nIf you provide custom weights, their mean should be 1 across trials with the same tag if stimOrMark is a stimumatios vector, within each vector if they are marker vectors.\n\nlinComb: Optional linear combination to be applied to the trials, e.g., a spatial filter. It can be:\nan integer: extract for each (weighted) trial only the data at the electrode indexed by linComb 1n (linear combination by a one-hot vector)\na vector f of N real elements: extract for each (weighted) trial the linear combination X_jf.\noffset: see offset.\n\nReturn\n\nif stimOrMark is a stimulation vector, return a vector of trials or of linear combinations thereof.\nif stimOrMark is marker vectors, return:\na vector of vectors of trials or of linear combinations threof if shape ≠ :cat,\nall trials or the linear combinations threof concatenated in a single vector if shape == :cat.\n\nBy default shape is equal to :cat. Empty marker vectors are ignored if shape is equal to :cat, otherwise an empty vector is returned in their corresponding positions.\n\nEach extracted trial is a wlN matrix if linComb is nothing (default),  otherwise it a vector wl elements.\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\nxxx # \n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Eegle.ERPs.trialsWeights","page":"Event-Related Potentials","title":"Eegle.ERPs.trialsWeights","text":"    function trialsWeights( X::Matrix{R}, \n                            stimOrMark::Union{Vector{S}, Vector{Vector{S}}}, \n                            wl::S;\n        M::Union{Matrix{R}, Nothing} = nothing,\n        offset::S = 0) \n    where {R<:Real, S<:Int}\n\n\nCompute adaptive weights for trials as the inverse of their squared Frobenius norm, along the lines of (Congedo et al., 2016). The method is unsupervised, i.e., agnostic to class labels, but a supervised version is available using the M arguments.\n\ntip: Mean ERPs\nYou don't need this function to compute weighted mean ERPs, as this function is called by mean.\n\nArguments\n\nX: the whole EEG recording, a matrix of size TN, where T is the number of samples and N the number of channels (sensors), respectively\nstimOrMark: either a stimulation vector or marker vectors. For empty mark vectors, an empty vector is returned\nwl: the window (trial or ERP) length in samples.\n\nOptional Keyword Arguments\n\nM: (defalut = nothing)\nif stimOrMark is a stimulation vector and a matrix is passed as M, then the weights are computed as the squared norm of X_j-M for all trials X_j, j in 1 ldots k, regardless their class\nif stimOrMark are marker vectors and a vector of z matrices is passed as M, then the weights are computed as the squared norm of X_j(i)-M_i for all trials  X_j(i), j in 1 ldots k, i in i ldots z for each class i separately.\noffset: see offset.\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\nxxx # \n\n\n\n\n\n","category":"function"},{"location":"ERPs/#Eegle.ERPs.reject","page":"Event-Related Potentials","title":"Eegle.ERPs.reject","text":"    function reject(X::Matrix{R}, \n                    stim::Vector{Int}, \n                    wl::S;\n        offset::S = 0,\n        upperLimit::Union{R, S} = 1.2,\n        returnDetails::Bool=false) \n    where {R<:Real, S<:Int}\n\nAutomatic rejection of artefacted trials in tagged EEG data by automatic amplitude thresholding.\n\ntip: Read data and reject artifacts\nThis function is called by Eegle.InOut.readNY to perform artifact rejection while reading EEG data in the NY format.\n\nArguments\n\nX: the whole EEG recording, a matrix of size TN, where T is the number of samples and N the number of electrodes\nstim: a stimulation vector\nwl: the trial length, i.e., the ERPs or trial duration, in samples.\n\nOptioanl Keyword Arguments\n\noffset: see offset\nupperLimit: modulate the definition of the upper threshold (see below). a reasonable value ∈[1, 1.6]\nupperLimit: determine the output (see below).\n\nDescription\n\nLet v be the natural logarithm of the field root mean square (FRMS, see Eegle.Processing.globalFieldRMS) of X sorted in ascending order.\n\nThe lower threshold l is defined as the tenth value of v (robust minimum estimator).\n\nThe upper threshold h is defined as\n\nh=m+((m-l)u),\n\nwhere:\n\nm is the mean of the 2wl central values of v, taken as a robust central tendency estimator\nu is kwarg upperlimit (default=1.2).\n\nAll trials in which at least one sample of the log-FRMS exceeds h or in which l exceeds the log-FRMS are rejected.\n\nReturn\n\nif returnDetails is false (default), a 5-tuple holding the following objects:\nthe stimulation vector stim with the tags corresponding to rejected trials set to zero (accepted trials),\nthe stimulation vector stim with the tags corresponding to accepted trials set to zero (rejected trials),\nthe first object as marker vectors,\nthe second object as marker vectors,\nthe number of rejected trials per class as a vector of integers.\nif returnDetails is true, a 9-tuple holding the above 5 objects and, in addition:\nthe log-FMRS (not sorted),\nthe mean m,\nthe lower threshold l,\nthe upper threshold h.\n\ntip: Algebraic relation\nThe elemet-wise sum of the first two returned objects is equal to the input stimulation vector stim.\n\nExamples\n\nusing Eegle # or using Eegle.ERPs\n\nxxx\n\ncleanstim, rejecstim, cleanmark, rejecmark, rejected = reject(X, stim, wl; upperLimit=1.5)\n\nR = reject(X, stim, wl; upperLimit=1.5, returnDetails = true) # R is a tuple of 9 objects\n\nnorm((R[1].+R[2]).-stim)==0 # should be true\n\nTutorials\n\nxxx\n\n\n\n\n\n","category":"function"},{"location":"documents/TreatmentMI/#Data-Treatment-for-Motor-Imagery-Databases","page":"TreatmentMI","title":"Data Treatment for Motor Imagery Databases","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"This document describes all the changes applied to downloaded Motor Imagery databases from MOABB to achieve standardization in the CSV format.","category":"page"},{"location":"documents/TreatmentMI/#AlexMI","page":"TreatmentMI","title":"AlexMI","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 2-right_hand, 3-feet, 4-rest\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Epoch labeling correction: In the original data, entire epochs were labeled with the corresponding event class, which could cause problems in NY format and misinterpretation during epoch slicing. This was corrected by maintaining the label only at the first sample of each epoch, setting all other samples in the labeled blocks to 0.","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Technical Note: Typically, the stimulation channel has a non-zero value when an event is triggered (e.g., 1 for left-hand) at one specific sample. When data is sliced into epochs, an epoch starts at the trigger sample and ends at the trigger sample + window length samples (window length = trial length × sampling rate, e.g., for this database: trial length = 3s, sampling rate = 256Hz, window length = 3×256 = 768 samples).","category":"page"},{"location":"documents/TreatmentMI/#BNCI2014001","page":"TreatmentMI","title":"BNCI2014001","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand, 3-feet, 4-tongue\nModified: 4-tongue → 6-tongue (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 250Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Offset addition: 2-second offset added as per the original paper's instructions (first 2 seconds after trigger correspond to visual cue indicating incoming MI task)\nChannel removal: EOG channels removed\nSession concatenation: Runs concatenated into corresponding sessions (identical experimental conditions)","category":"page"},{"location":"documents/TreatmentMI/#BNCI2014002","page":"TreatmentMI","title":"BNCI2014002","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-right_hand, 2-feet\nModified: 1-righthand → 2-righthand, 2-feet → 3-feet (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Data cleaning: Samples with NaN and/or zero values removed (first and last lines)\nOffset addition: 3-second offset added as per the original paper's instructions (first 3 seconds after trigger correspond to visual cue indicating incoming MI task)\nDatabase separation:\nBNCI2014002-Train: Runs 1-5 (no feedback, used for classifier training)\nBNCI2014002-Test: Runs 6-8 (with feedback, used for classifier testing)","category":"page"},{"location":"documents/TreatmentMI/#BNCI2014004","page":"TreatmentMI","title":"BNCI2014004","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 250Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Data cleaning: Samples with NaN and/or zero values removed\nChannel removal: EOG channels removed\nOffset addition: 3-second offset added as per the original paper's instructions (first 3 seconds after trigger correspond to visual cue indicating incoming MI task)\nDatabase separation:\nBNCI2014004-Train: Sessions 1-2 (no feedback, used for classifier training)\nBNCI2014004-Test: Sessions 3-5 (with feedback, used for classifier testing)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Warning: Session 3 is labeled as training in MOABB but as testing in the original paper. We followed the original paper classification.","category":"page"},{"location":"documents/TreatmentMI/#BNCI2015001","page":"TreatmentMI","title":"BNCI2015001","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-right_hand, 2-feet\nModified: 1-righthand → 2-righthand, 2-feet → 3-feet (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Session handling: 2-3 sessions per subject with identical experimental conditions (no separation required)","category":"page"},{"location":"documents/TreatmentMI/#Cho2017","page":"TreatmentMI","title":"Cho2017","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Channel removal: EMG channels removed","category":"page"},{"location":"documents/TreatmentMI/#GrossWentrup2009","page":"TreatmentMI","title":"GrossWentrup2009","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 500Hz\nModified: Downsampled to 250Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"No additional changes required","category":"page"},{"location":"documents/TreatmentMI/#Lee2019MI","page":"TreatmentMI","title":"Lee2019MI","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-righthand, 2-lefthand\nModified: 1-righthand → 2-righthand, 2-lefthand → 1-lefthand (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1000Hz\nModified: Downsampled to 200Hz (decimation factor = 5)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Channel removal: EMG channels removed\nSession handling: 2 sessions with identical experimental conditions (no separation required)","category":"page"},{"location":"documents/TreatmentMI/#PhysionetMI","page":"TreatmentMI","title":"PhysionetMI","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-rest, 2-lefthand, 3-righthand, 4-both_hands, 5-feet\nModified: 1-rest → 4-rest, 2-lefthand → 1-lefthand, 3-righthand → 2-righthand, 4-bothhands → 5-bothhands, 5-feet → 3-feet (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 160Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Data cleaning: Samples with NaN and/or zero values removed\nTask selection: Only imagined movement tasks included (Tasks 1 and 3 with executed movements excluded)\nDatabase separation:\nPhysionetMI-T2: Task 2 (lefthand and righthand classes) - Runs 4, 8, 12 concatenated\nPhysionetMI-T4: Task 4 (both_hands and feet classes) - Runs 6, 10, 14 concatenated","category":"page"},{"location":"documents/TreatmentMI/#Schirrmeister2017","page":"TreatmentMI","title":"Schirrmeister2017","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-feet, 2-lefthand, 3-rest, 4-righthand\nModified: 1-feet → 3-feet, 2-lefthand → 1-lefthand, 3-rest → 4-rest, 4-righthand → 2-righthand (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 500Hz\nModified: Downsampled to 250Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Session concatenation: Train and test runs concatenated into single session (identical experimental conditions)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Warning: When using paradigm.get_data() from MOABB for .yml metadata acquisition, class labels differ from the original paper. Original labels were used for CSV to NY conversion.","category":"page"},{"location":"documents/TreatmentMI/#Shin2017A","page":"TreatmentMI","title":"Shin2017A","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 200Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Channel removal: EOG channels removed\nSession handling: 3 sessions with identical experimental conditions (no separation required)","category":"page"},{"location":"documents/TreatmentMI/#Weibo2014","page":"TreatmentMI","title":"Weibo2014","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand, 3-both_hands, 4-feet, 7-rest\nModified: 3-bothhands → 5-bothhands, 4-feet → 3-feet, 7-rest → 4-rest (standardization)","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 200Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Offset addition: 3-second offset added as per the original paper's instructions (first 3 seconds after trigger correspond to visual cue indicating incoming MI task)\nChannel removal: EOG and CB channels removed (CB electrodes purpose unclear)\nData cleaning: Samples with NaN and/or zero values removed","category":"page"},{"location":"documents/TreatmentMI/#Zhou2016","page":"TreatmentMI","title":"Zhou2016","text":"","category":"section"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 1-lefthand, 2-righthand, 3-feet\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Original: 250Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentMI/","page":"TreatmentMI","title":"TreatmentMI","text":"Session concatenation: 3 sessions of 2 runs each with identical conditions, runs concatenated into corresponding sessions\nChannel removal: EOG channels removed","category":"page"},{"location":"documents/Databases Summary MI/#Database-Summary-for-MI-Paradigm","page":"databases Summary MI","title":"Database Summary for MI Paradigm","text":"","category":"section"},{"location":"documents/Databases Summary MI/","page":"databases Summary MI","title":"databases Summary MI","text":"Database Condition Subjects Sessions (min,max) Sensors Sensor Type Classes Class Labels Trials/Class (min,max) Sampling Rate Window Length Offset\nAlexMI None 8 1 16 Ag/AgCl Wet 3 RH, F, R 20 256 768 0\nBNCI2014001 None 9 2 22 Ag/AgCl Wet 4 LH, RH, F, T 72 250 1000 500\nBNCI2014002 Test 14 1 15 Ag/AgCl Wet 2 RH, F 30 256 1280 768\nBNCI2014002 Train 14 1 15 Active Ag/AgCl Wet 2 RH, feet 50 256 1280 768\nBNCI2014004 Test 9 3 3 Ag/AgCl Wet 2 LH, RH (60, 80) 250 1125 750\nBNCI2014004 Train 9 2 3 Ag/AgCl Wet 2 LH, RH (60, 80) 250 1125 750\nBNCI2015001 None 12 (2, 3) 13 Active 2 RH, F 100 256 1280 0\nCho2017 None 52 1 64 Active Ag/AgCl 2 LH, RH (100, 120) 256 768 0\nGrosseWentrup2009 None 10 1 128 N/A 2 LH, RH 150 250 1750 0\nLee2019_MI Train 54 2 62 Ag/AgCl 2 vleft_hand`, RH 50 200 800 0\nPhysionetMI Task 2 109 1 64 N/A 3 LH, RH, R (18, 57) 160 480 0\nPhysionetMI Task 4 109 1 64 N/A 3 F, R, BH (18, 57) 160 480 0\nSchirrmeister2017 None 14 1 128 Ag/AgCl wet 4 LH, RH, F, R (120, 265) 250 1000 0\nShin2017A None 29 3 30 Active Dry 2 LH, RH 10 200 2000 0\nWeibo2014 None 10 1 60 Ag/AgCl 5 LH, RH, F, R, BH (70, 80) 200 800 600\nZhou2016 None 4 3 14 N/A 3 LH, RH, F (45, 60) 250 1250 0","category":"page"},{"location":"documents/Databases Summary MI/","page":"databases Summary MI","title":"databases Summary MI","text":"Legend: LH = LH; right_hand = RH; , feet = F, , both-hands = BH, tongue= T; rest = R","category":"page"},{"location":"Eegle/#Eegle","page":"Eegle Package","title":"Eegle","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Eegle is organized as a collection of independent modules. They are all re-exported, along with fundamental external packages, forming an integrated library. Thus, if you state","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"using Eegle","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"you have access of all functions exported by all Eegle modules and by all re-exported external packages.","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Like external packages, Eegle modules can be used individually.  For example, if you only need some functions for preprocessing and signal processing, you can state","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"    using Eegle.preprocessing, DSP","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"In this case, however, you must install DSP.jl as well.","category":"page"},{"location":"Eegle/#Eegle-Integrated-Library","page":"Eegle Package","title":"Eegle Integrated Library","text":"","category":"section"},{"location":"Eegle/#Internal-modules","page":"Eegle Package","title":"Internal modules","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Code Unit Description\nBCI.jl Brain-Computer Interface machine learning based on Riemannian geometry\nDatabase.jl utilities for handling databases\nERPs.jl operations on Event-Related Potentials and BCI trials\nFileSystem.jl manipulation of files and directories\nInOut.jl reading and writing of data\nMiscellaneous.jl miscellaneous functions\nPreprocessing.jl EEG preprocessing\nProcessing.jl EEG Processing","category":"page"},{"location":"Eegle/#Re-exported-external-packages","page":"Eegle Package","title":"Re-exported external packages","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Package Scope\nCovarianceEstimation covariance matrix estimations\nDiagonalizations spatial filters, (approximate joint) diagonalization\nDistributions statistical distributions\nDSP Julia standard package for digital signal processing\nFourierAnalysis FFT-based Frequency domain and time-frequency domain\nLinearAlgebra Julia standard package for matrix type and algebra, BLAS, LAPACK\nNPZ support for the NPZ (NumPy) bynary format\nPermutationTests ow-level statistics, (multiple comparison) permutation tests\nPosDefManifold ore linear algebra, operations on the manifold of positive-definite matrices\nPosDefManifoldML machine learning on the manifold of positive-definite matrices\nStatsBase Julia standard package for basic statistics\nStatistics Julia standard package for statistics","category":"page"},{"location":"Eegle/#Used-but-not-re-exported-external-packages","page":"Eegle Package","title":"Used but not re-exported external packages","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Package Scope\nCSV support for CSV format\nDataFrames manipulation of tables\nDates standard Julia support for dates and time manipulation\nEzXML support for XML/HTML data formats\nFolds multi-threaded basic functions\nHDF5 Support for the HDF5 data format\nPrettyTables print data in tables and matrices in a human-readable format\nRandom random generators\nReexport julia macro to re-export symbols (purely internal)\nRevise for development: automatically update function definitions in a running Julia session\nTest for development: Julia standard library for integrating package testing\nYAML support for YAML format","category":"page"},{"location":"Eegle/#Other-resources","page":"Eegle Package","title":"Other resources","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"There are many other Julia's packages that can be useful for EEG data analysis and classification. Here is a non-exhaustive list of links to find resources:","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Package Scope\nJulia Neuro A collection of packages gor Neuroscience data\nUnfold.jl An ecosystem for ERP analysis","category":"page"},{"location":"Eegle/#Tips-and-Tricks","page":"Eegle Package","title":"Tips & Tricks","text":"","category":"section"},{"location":"Eegle/#General-T-and-T","page":"Eegle Package","title":"General T&T","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Julia is a just-in-time compiled, column-major, 1-based indexing language. In practice for using this package this means that:","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"The first time you execute a function, it will be compiled. From the second on, it will go fast\nEEG data are organized in TN matrices, where T and N denotes the number of samples and channels, respectively\nfor loops starts at 1. For indexing, whenever possible, in Julia you should prefer using eachindex.","category":"page"},{"location":"Eegle/#ℍ-and-the-ℍVector-type","page":"Eegle Package","title":"ℍ and the ℍVector type","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"Covariance matrices and vectors thereof play an important role in EEG data analysis and classification. Eegle follows the framework of package PosDefManifold, which requires flagging these matrices as Hermitian. Reading this documentation on typecasting matrices can turn useful.","category":"page"},{"location":"Eegle/#How-to-Contribute","page":"Eegle Package","title":"How to Contribute","text":"","category":"section"},{"location":"Eegle/#Code-conventions","page":"Eegle Package","title":"Code conventions","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"When using a method of the Eegle package, qualify the module it is taken from, for example: \nEegle.FileSystem.getFilesInDir(dbDir; ext=(\".npz\", ), isin)\nCommunicate the module and function when printing a messages within a function, for example: \n@warn \"Eegle.Database, function loadNYdb: the $filemane files has not been found:\\n\"\nThe name of internal functions (not-exported) begins by an underscore, for example: \nfunction _weightsDB(...)\nThe name of functions modifying one or more arguments ends with an exclamation mark, for example:\nfunction myFunc!(...)\nWhenever appropriate, methods should give feedback to the user. Use meaningful symbols such as:\n✓, ✗, ⊘, ⚠️ — see here for a list of supported unicode symbols\nFor name of functions composed by several words, capitalize the words starting from the second, for example:\nfunction myFunc(...)\nAcronyms in name of functions may or may not be fully capitalized, for example: \nfunction weightsDB(...)\nIf you add a method in a module, update the commented \"CONTENT\" section in the module's header\nIf you add a new public function in a module, make sure: \nyou add the documentation right on top of the function (no blank lines)\nyou add the function in the export section of the module\nyou add the function in the docstring of the module's .md file in the docs/src directory.\nLeave an empty space around the = sign\nFollows Julia general conventions:\nfunctions starts by a lower-case letter, while structures and modules by a capital letter \nin general, constants are fully capitalized\nfunctions modifying one or more of the arguments start by !\ninternal functions start by _.","category":"page"},{"location":"Eegle/#Documentation","page":"Eegle Package","title":"Documentation","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"For simple functions and methods, the documentation should be short and rather illustrated by examples\nFor complex functions and methods (in general, four or more arguments), the documentation can comprise up to six sections: \nTutorial (if tutorials are available)\nDescription (if the method is not simple and common knowledge)\nArguments (if applicable) \nOptional Keyword Arguments (if applicable)\nReturn (always)\nExamples (unless it is trivial). \nWhenever relevant, the documentation of functions should include (before the Examples section):\na See line providing the link to related functions in Eegle\na See Also line providing the link to somehow related functions or to function not in Eegle\nAlways start the Examples section with line:","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"using Eegle ","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"When a function has more then two arguments and optional keyword arguments (kwargs), they are given as a list    and their possible values, whenever relevant, as a sub-list \nEnclose functions, arguments and optional keyword arguments in backticks, for example, mean\nUse acronym and refer to the Acronyms section, e.g., BSS\nThe correct way to link composite headings is NY format (note the lower case and dash)\nDo not confuse the em dash hyphen — (a long dash used in text punctuation) with the usual en dash, used, for example, to make lists in markdown.\nOnly the last item of a list or sub-list should end with a dot\nThe first word of the title of admonitions ('tip', 'warning', etc.) is capitalized, unless it is a function or argument.\nFully qualify links to functions of other modules, for example: Eegle.Preprocessing.removeSamples, except:\nfunctions whose name is imported from an existing external package, for example: mean\nfunctions defined in the same module you are writing the documentation in.\nFor Markdown text:\nheadings of level 1 and 2 capitalze all words\nheadings of level 3 capitalize only the first word\nheadings of level 4 do not capitalize any words. ","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"To get started, use the existing documentation as a template.","category":"page"},{"location":"Eegle/#Notation-and-Nomenclature","page":"Eegle Package","title":"Notation & Nomenclature","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"The following notation is followed throughout the code:","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"quantities are denoted by upper case letters and their index by lower-case letters, e.g., n1N\nvectors are denoted using lower-case letters, e.g., y,\nmatrices using upper case letters, e.g., X\nsets (vectors) of matrices using bold upper-case letters, e.g., 𝐗 (escape sequence \\bfX).","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"In the code examples, bold upper-case letters may replaced by upper case letters in order to facilitate testing the code in the REPL.","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"The following nomenclature is used consistently:","category":"page"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"X: an EEG data matrix (𝐗: a vector of EEG data matrices)\nC, P, Q: positive-definite matrices (idem)\nD: a diagonal matrix (idem)\nU: an orthogonal matrix (idem)\nλ: an eigenvalue (idem)\no: an EEG data structure (idem)\ny: a vector of class labels\nz: number of classes for ERP or BCI data\nk: number of matrices in a set","category":"page"},{"location":"Eegle/#Acronyms","page":"Eegle Package","title":"Acronyms","text":"","category":"section"},{"location":"Eegle/","page":"Eegle Package","title":"Eegle Package","text":"AI: affine-invariant (also known as Fisher-Rao metric)\nBCI: brain-computer interface\nBSS: Blind Source Separation\nCAR: common average reference\ncv: cross-validation\nEEG: electroencephalography\nENLR: elastic-net logistic regression\nERP: event-related potential\nkwarg: (optional) keyword argument\nMLM: machine learning model\nMDM: minimum distance to mean\nMI: motor Imagery (a BCI paradigm)\nP300: the P300 BCI paradigm\nPCA: principal component analysis\nSCM: sample covariance (maximum lakelihood) estimator\nSVM: support-vector machine","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/#Tutorial-ML-1","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"","category":"section"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"A common task in BCI reasearch is to test a machine learning model (MLM) on a large amount of real data. This tutorial uses the FII-BCI corpus in NY format as an example.","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"The tutorial shows how to","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"Select databases and sessions from the FII-BCI corpus accoording to:\nBCI Paradigm (Motor Imagery or P300)\navailability of specific classes\nminimum number of trials per class\nRun a cross-validation for all selected sessions in all selected databases\nShow a summary of the cross-validation results for each session.","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"info: Info\nAs a MLM, the MDM Riemannian classifier employing the affine-invariant (Fisher-Rao) metric is used (Barachant et al., 2012), (Congedo et al., 2017). As a covariance matrix estimator, the linear shrinkage estimator of (Ledoit and Wolf, 2004) is used.For each session, an 8-fold stratified cross-validation is run. The summary of results comprises the mean and standard deviation of the balanced accuracy obtained across the folds as well as the z-score and p-value of the cross-validation test-statistic — see crval for details.","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"using Eegle # tell julia you want to use the Eegle package","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"First, declare a function for performing the cross-validation for both the MI and P300 paradigm, given arguments: ","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"file: the full path of the sesson file on which the MLM is to be validated \nparadigm: either :MI or :P300\nbandPass: band-pass region for the filter to be applied to the data\nupperLimit: the only parameter for adaptive thresholding artifact-rejection, passed to reject\ngetTrials: the classes on which you want to select the databases, train and test the classifier <!– @Marco ajouté –>\ncovtype: the desired covariance estimation for encoding trials, passed to encode\nstandardize : standardize the data matrix(ces) before estimating the covariance. <!– @Marco à modifier si voulu  –>\nmetric: the desired metric for the MDM classifier\nnFolds: the number of stratified folds for the cross-validation, passed to crval.","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"function cv(file; paradigm, bandPass, upperLimit, getTrials, covtype, standardize, metric, nFolds) #@Marco oublie de quelques args, corrigé \n\n    println(\"File: \", file)\n    \n    #= To perform a cross-validation we need to \n    - read the session data,\n    - encode the trials according to Riemannian geometry methodology\n    - fit and evaluate a MDM Riemannian classifier in a stratified fold fashion\n    =#\n\n    # Read session data: Eegle.InOut.readNY\n    o = readNY(file; bandPass, upperLimit, getTrials);\n\n    # Trials encoding (a form of Covariance estimation): Eegle.BCI.encode @Marco different encoding for P300\n    if paradigm == :MI\n        𝐂 = encode(o, paradigm; covtype, standardize);\n    elseif paradigm == :P300\n        𝐂 = encode(o, paradigm; covtype=LShrLW, targetLabel=\"target\", standardize);\n    end\n\n    # Cross-validation: PosDefManifoldML.crval\n    cvRes = crval(MDM(metric), 𝐂, o.y; nFolds)\n\n    return cvRes    \nend;\n\n# optional keyword arguments for `cv`, which are common to the MI and P300 paradigm\nargs = (upperLimit = 1, covtype=LShrLW, \n        standardize = false, \n        metric = PosDefManifold.Fisher, \n        nFolds = 8);","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"Function cv return a CVres structure, which store the result of the cross-validation.","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"Next, declare a function to show a summary of the results given database DB and the associated vector res of CVres structures.  ","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"function show_results(DB, res) \n    println(\"Database: \", DB.dbName)\n    println(\"mean and sd balanced accuracy, z and p-value against chance level\")  \n    for (i, r) ∈ enumerate(res) # @Marco ajout de enumerate car causer un bug, amélioration de l'affichage plus claire désormais\n        println(\"File \", i, \". mean(sd): \", round(r.avgAcc*100, digits=2) ,\"% (± \", round(r.stdAcc*100, digits=2), \" %); \", \n                \"z(p-value): \", round(r.z, digits=4), \"(\", r.p, \")\")\n    end\n    println(\"\\n\")\nend;","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"Finally, perform the cross-validation on all available MI databases featuring the left_hand and right_hand class, as","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"MIDir = joinpath(homedir(), \"BCI Databases\", \"NY\",\"MI\") # path to MI databases\nclasses = [\"feet\", \"right_hand\"]\nDBs = selectDB(MIDir, :MI; classes);\n\nfor (db, DB) ∈ enumerate(DBs)\n    res = [cv(file; bandPass=(8, 32), paradigm=:MI, getTrials=classes, args...) for file ∈ DB.files] # @Marco oubli de paradigm ici, a été rajouté\n    show_results(DB, res)\nend","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"or perform and cross-validation on all available P300 databases featuring at least 20 trials for both the target and non-target class, as","category":"page"},{"location":"Tutorials/Tutorial Machine Learning 1/","page":"Tutorial ML 1","title":"Tutorial ML 1","text":"P300Dir = joinpath(homedir(), \"BCI Databases\",\"NY\",\"P300\") # path to P300 databases\n# @Marco quand le paradigm est P300, selectDB ne prend pas l'argument classes, \n# car elles ne changent jamais les deux sont toujours obligatoires (tu m'avais dis de faire ca au moment ou jai creer la fonction , \n# si on utilise classes avec P300 la fonction envoie un warning dans selectDB)\nDBs = selectDB(P300Dir, :P300; minTrials = 20);\n\nfor (db, DB) ∈ enumerate(DBs)\n    res = [cv(file; bandPass=(1, 24), paradigm=:P300, getTrials = true, args...) for file ∈ DB.files] # @Marco oubli de paradigm ici, a été rajouté\n    show_results(DB, res)\nend","category":"page"},{"location":"documents/TreatmentP300/#Data-Treatment-for-P300-Databases","page":"TreatmentP300","title":"Data Treatment for P300 Databases","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"This document describes all the changes applied to downloaded P300 databases from MOABB or the base repository to achieve standardization in the CSV format.","category":"page"},{"location":"documents/TreatmentP300/#BNCI2014009","page":"TreatmentP300","title":"BNCI2014009","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 2-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 256Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel removal: Flash channel removed\nSession handling: 3 sessions with identical experimental conditions (no separation required)\nEpoch labeling correction: In the original data, entire epochs were labeled with the corresponding event class, which could cause problems in NY format and misinterpretation during epoch slicing. This was corrected by maintaining the label only at the first sample of each epoch, setting all other samples in the labeled blocks to 0.","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Technical Note: Typically, the stimulation channel has a non-zero value when an event is triggered (e.g., 1 for nontarget) at one specific sample. When data is sliced into epochs, an epoch starts at the trigger sample and ends at the trigger sample + window length samples (window length = trial length × sampling rate, e.g., for this database: trial length = 1s, sampling rate = 256Hz, window length = 1×256 = 256 samples).","category":"page"},{"location":"documents/TreatmentP300/#BNCI2015003","page":"TreatmentP300","title":"BNCI2015003","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 2-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 256Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel removal: Flash channel removed\nEpoch labeling correction: In the original data, entire epochs were labeled with the corresponding event class, which could cause problems in NY format and misinterpretation during epoch slicing. This was corrected by maintaining the label only at the first sample of each epoch, setting all other samples in the labeled blocks to 0.\nDatabase separation:\nBNCI2015003-Train: User attempted to spell \"WATER\" with no feedback (classifier training)\nBNCI2015003-Test: User attempted to spell \"LUCAS\" with feedback (classifier testing)","category":"page"},{"location":"documents/TreatmentP300/#Cattan2019","page":"TreatmentP300","title":"Cattan2019","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 1-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel merging: Original file contained separate nontarget and target stimulation channels (both using value 1 at the beginning of the trial). These were merged into a single stimulation channel with standardized labels.\nChannel removal: Event channel and two irrelevant final columns removed\nDatabase separation:\nCattan2019-PC: P300 signals displayed on personal computer\nCattan2019-VR: P300 signals displayed on VR headset","category":"page"},{"location":"documents/TreatmentP300/#EPFLP300","page":"TreatmentP300","title":"EPFLP300","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 1-Target\nModified: 1-Target → 2-Target (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 2048Hz\nModified: Downsampled to 256Hz (decimation factor = 8)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Database separation: 4 sessions with 6 runs per subject. Sessions were experimentally identical, but runs differed based on target image focus.\nSeparated into 6 databases: EPFLP300-1 to EPFLP300-6, corresponding to different target images (e.g., run 1 focused on television image)","category":"page"},{"location":"documents/TreatmentP300/#Lee2019ERP","page":"TreatmentP300","title":"Lee2019ERP","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 2-Non-Target, 1-Target\nModified: \"nontarget\" → 1, \"target\" → 2. (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1000Hz\nModified: Downsampled to 200Hz (decimation factor = 5)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel removal: EMG channels removed\nDatabase separation:\nLee2019ERP-Train: User copy-spelled \"NEURAL NETWORKS AND DEEP LEARNING\" (classifier training)\nLee2019ERP-Test: User copy-spelled \"PATTERN RECOGNITION MACHINE LEARNING\" (classifier testing)","category":"page"},{"location":"documents/TreatmentP300/#bi2012","page":"TreatmentP300","title":"bi2012","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 1-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 128Hz\nModified: No changes required","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel merging: Original file contained separate nontarget and target stimulation channels (both using value 1 at trial beginning). These were merged into a single stimulation channel with standardized labels.\nDatabase separation:\nbi2012-T: Offline training session (offline, predefined target sequence)\nbi2012-O: Online testing session (online, randomized sequence)","category":"page"},{"location":"documents/TreatmentP300/#bi2013a","page":"TreatmentP300","title":"bi2013a","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 33286-Non-Target, 33285-Target\nModified: \"nontarget\" → 1, \"target\" → 2. (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Database separation: 4 sessions with different experimental conditions:\nbi2013a-NAT: Non-Adaptive Training (offline, predefined target sequence)\nbi2013a-NAO: Non-Adaptive Online (online, randomized sequence)\nbi2013a-AT: Adaptive Training (offline, predefined target sequence)\nbi2013a-AO: Adaptive Online (online, randomized sequence)","category":"page"},{"location":"documents/TreatmentP300/#bi2014a","page":"TreatmentP300","title":"bi2014a","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 2-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel removal: Event column removed\nSession handling: Single session with 1 run (no separation required)","category":"page"},{"location":"documents/TreatmentP300/#bi2014b","page":"TreatmentP300","title":"bi2014b","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 2-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Session selection: Originally a multiplayer version of bi2014a, but one solo session per subject was recorded and were included as they were the only ones respecting the oddball paradigm\nSubject separation: Original files contained both subjects with interleaved EEG channels (half for subject 1, half for subject 2). These were separated into distinct files for standardization.","category":"page"},{"location":"documents/TreatmentP300/#bi2015a","page":"TreatmentP300","title":"bi2015a","text":"","category":"section"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Class Labels:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 1-Non-Target, 2-Target\nModified: \"nontarget\" → 1, \"target\" → 2 (standardization)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Sampling Rate:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Original: 512Hz\nModified: Downsampled to 256Hz (decimation factor = 2)","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Specific Treatments:","category":"page"},{"location":"documents/TreatmentP300/","page":"TreatmentP300","title":"TreatmentP300","text":"Channel merging: Original file contained separate non-target and target stimulation channels (both using value 1 at trial beginning). These were merged into a single stimulation channel with standardized labels.\nDatabase separation: 3 sessions with different flash durations:\nbi2015a-1: 110ms flash duration\nbi2015a-2: 80ms flash duration\nbi2015a-3: 50ms flash duration","category":"page"},{"location":"documents/Databases Summary P300/#Database-Summary-for-P300-Paradigm","page":"databases Summary P300","title":"Database Summary for P300 Paradigm","text":"","category":"section"},{"location":"documents/Databases Summary P300/","page":"databases Summary P300","title":"databases Summary P300","text":"Database Condition Subjects Sessions (min,max) Sensors Sensor Type Classes Class Labels Trials/Class (min,max) Sampling Rate Window Length Offset\nBNCI2014009 None 10 3 16 Ag/AgCl 2 NT, T NT: 480; T: 96 256 205 0\nBNCI2015003 Test 10 1 8 Active Ag/AgCl or Gold 2 NT, T NT: (750, 2625); T: (75, 150) 256 205 0\nBNCI2015003 Train 10 1 8 Active Ag/AgCl or Gold 2 NT, T NT: (750, 2625); T: (75, 150) 256 205 0\nCattan2019 Personal Computer (PC) 21 1 16 Wet 2 NT, T NT: 600; T: 120 256 256 0\nCattan2019 Virtual Reality (VR) 21 1 16 Wet 2 NT, T NT: 600; T: 120 256 256 0\nEPFLP300 Run 1 - Television 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 125); T: (20, 25) 256 256 0\nEPFLP300 Run 2 - Telephone 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 125); T: (20, 25) 256 256 0\nEPFLP300 Run 3 - Lamp 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 125); T: (21, 25) 256 256 0\nEPFLP300 Run 4 - Door 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 125); T: (20, 25) 256 256 0\nEPFLP300 Run 5 - Window 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 125); T: (21, 25) 256 256 0\nEPFLP300 Run 6 - Radio 8 4 32 Ag/AgCl Wet 2 NT, T NT: (103, 124); T: (20, 25) 256 256 0\nLee2019_ERP Test 54 2 62 Ag/AgCl 2 NT, T NT: 1800; T: 360 200 200 0\nLee2019_ERP Train 54 2 62 Ag/AgCl 2 NT, T NT: (1649, 1650); T: 330 200 200 0\nbi2012 Online 25 1 16 Ag/AgCl Wet 2 NT, T NT: (250, 660); T: (49, 132) 128 128 0\nbi2012 Training 25 1 16 Ag/AgCl Wet 2 NT, T NT: (632, 640); T: (126, 128) 128 128 0\nbi2013a Adaptative - Online 24 (1, 8) 16 Ag/AgCl Wet 2 NT, T NT: (120, 280); T: (24, 56) 256 256 0\nbi2013a Adaptative - Training 24 (1, 8) 16 Ag/AgCl Wet 2 NT, T NT: 400; T: 80 256 256 0\nbi2013a Non Adaptative - Online 24 (1, 8) 16 Ag/AgCl Wet 2 NT, T NT: (130, 520); T: (26, 104) 256 256 0\nbi2013a Non Adaptative - Training 24 (1, 8) 16 Ag/AgCl Wet 2 NT, T NT: (400, 420); T: (80, 84) 256 256 0\nbi2014a None 64 1 16 Gold Alloy Dry 2 NT, T NT: (350, 1490); T: (70, 298) 256 256 0\nbi2014b Solo 38 1 32 Active wet 2 NT, T NT: (120, 430); T: (24, 86) 256 256 0\nbi2015a Flash Duration 110ms 43 1 32 Ag/AgCl Wet 2 NT, T NT: (270, 2145); T: (54, 429) 256 256 0\nbi2015a Flash Duration 80ms 43 1 32 Ag/AgCl Wet 2 NT, T NT: (270, 1383); T: (54, 276) 256 256 0\nbi2015a Flash Duration 50ms 43 1 32 Ag/AgCl Wet 2 NT, T NT: (270, 870); T: (54, 174) 256 256 0","category":"page"},{"location":"documents/Databases Summary P300/","page":"databases Summary P300","title":"databases Summary P300","text":"Legend: NT=nontarget; T=target","category":"page"},{"location":"documents/Example Data/#Example-Data","page":"Example Data","title":"Example Data","text":"","category":"section"},{"location":"documents/Example Data/","page":"Example Data","title":"Example Data","text":"Eegle deploys example EEG data files in NY format to be used in examples and tutorials. This format is read by fucntion readNY, which creates an EEG structure including the data and metadata.  The complete path to the file is is accessible anywhere as Eegle.{CONSTANT}, where {CONSTANT} is one of the heading here below. See the tutorials.","category":"page"},{"location":"documents/Example Data/#EXAMPLE_MI_1","page":"Example Data","title":"EXAMPLE_MI_1","text":"","category":"section"},{"location":"documents/Example Data/","page":"Example Data","title":"Example Data","text":"This is the file corresponding to the first session of the first subject  of motor-imagery Brain-Computer Interface database Alex MI","category":"page"},{"location":"documents/Example Data/#EXAMPLE_P300_1","page":"Example Data","title":"EXAMPLE_P300_1","text":"","category":"section"},{"location":"documents/Example Data/","page":"Example Data","title":"Example Data","text":"This is the file corresponding to the first session of the first subject  of P300 Brain-Computer Interface database bi2012-T","category":"page"},{"location":"FileSystem/#FileSystem.jl","page":"File System","title":"FileSystem.jl","text":"","category":"section"},{"location":"FileSystem/","page":"File System","title":"File System","text":"This module implements utilities for working with files and directories.","category":"page"},{"location":"FileSystem/","page":"File System","title":"File System","text":"It is a complement to the standard Julia FileSystem module.","category":"page"},{"location":"FileSystem/","page":"File System","title":"File System","text":"Function Description\nEegle.FileSystem.fileBase get a file path without the extension\nEegle.FileSystem.fileExt extract the extension from a file name, including the dot\nEegle.FileSystem.changeFileExt change the extension of a file\nEegle.FileSystem.getFilesInDir search for files in a directory and its subdirectories\nEegle.FileSystem.getFoldersInDir search for directories in a directory and its subdirectories","category":"page"},{"location":"FileSystem/","page":"File System","title":"File System","text":"📖","category":"page"},{"location":"FileSystem/#Eegle.FileSystem.fileBase","page":"File System","title":"Eegle.FileSystem.fileBase","text":"    function fileBase(file::String)\n\nReturn file, including the complete path, without the extension.\n\ntip: basename\nJulia basename returns the file with no path and with extension\n\nExample\n\nfileBase(joinpath(homedir(), \"myfile.txt\"))\n# return (joinpath(homedir(), \"myfile\"))\n\n\n\n\n\n","category":"function"},{"location":"FileSystem/#Eegle.FileSystem.fileExt","page":"File System","title":"Eegle.FileSystem.fileExt","text":"    function fileExt(file::String)\n\nReturn the extension of a file, including the dot.\n\nExample\n\nfileExt(joinpath(homedir(), \"myfile.txt\")) \n# return \".txt\" \n\n\n\n\n\n","category":"function"},{"location":"FileSystem/#Eegle.FileSystem.changeFileExt","page":"File System","title":"Eegle.FileSystem.changeFileExt","text":"    function changeFileExt(file::String, ext::String)\n\nReturn the complete path of file with extension changed to ext.\n\nExample\n\nchangeFileExt(joinpath(homedir(), \"myfile.txt\"), \".csv\") \n# return joinpath(homedir(), \"myfile.csv\")\n\n\n\n\n\n","category":"function"},{"location":"FileSystem/#Eegle.FileSystem.getFilesInDir","page":"File System","title":"Eegle.FileSystem.getFilesInDir","text":"    function getFilesInDir(dir::Union{String, Vector{String}}; \n        ext::Tuple=(), isin::String=\"\")\n\nReturn a vector of strings comprising the complete path of all files in directory dir.\n\nArguments\n\ndir, which can be a directory or a vector of directories.\n\nOptional Keyword Arguments\n\next is an optional tuple of file extensions. If it is provided, return only the files with those extensions. The extensions must be entered in lowercase.\nIf a string is provided as isin, return only those files whose name contains the string.\n\nExamples\n\nusing Eegle # or using Eegle.FileSystem\n\nS=getFilesInDir(@__DIR__) # start at current directory.\n\nS=getFilesInDir(@__DIR__; ext=(\".txt\", ))\n\nS=getFilesInDir(@__DIR__; ext=(\".txt\", \".jl\"), isin=\"Analysis\")\n\n\n\n\n\n","category":"function"},{"location":"FileSystem/#Eegle.FileSystem.getFoldersInDir","page":"File System","title":"Eegle.FileSystem.getFoldersInDir","text":"    function getFoldersInDir(dir::String; isin::String=\"\")\n\nReturn a vector of strings comprising the complete path of all directories in directory dir.\n\nIf a string is provided as kwarg isin, return only the directories whose name contains the string.\n\nExamples\n\nusing Eegle # or using Eegle.FileSystem\n\nS=getFoldersInDir(@__DIR__)\n\nS=getFoldersInDir(@__DIR__; isin=\"Analysis\")\n\n\n\n\n\n","category":"function"},{"location":"#Eegle-Documentation","page":"Eegle Documentation","title":"Eegle Documentation","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"The EEG General Library (Eegle) is a general-purpose package for preprocessing and processing human Electroencephalography (EEG) data.","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"It is the foundational building block that enables the integration of diverse state-of-the-art packages, leveraging the powerful Julia scientific eco-system.","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"It also provides some modules for advanced EEG analysis.","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Eegle promotes standardization, conventions and a learning approach based on simple examples and advanced tutorials.","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"(Image: Figure 1)","category":"page"},{"location":"#Requirements","page":"Eegle Documentation","title":"Requirements","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Julia: version ≥ 1.10","category":"page"},{"location":"#Installation","page":"Eegle Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Execute the following commands in Julia's REPL:","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"]add Eegle","category":"page"},{"location":"#Testing","page":"Eegle Documentation","title":"Testing","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Hit the backspace key (🡐) on your keyboard to get back the Julia prompt, then","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"using Pkg\nPkg.test(\"Eegle\")","category":"page"},{"location":"#Quick-Start","page":"Eegle Documentation","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Read the next page of this documentation for general informations, then work out the tutorials. When you need a function, check its documentation and the examples given therein.","category":"page"},{"location":"#About-the-Authors","page":"Eegle Documentation","title":"About the Authors","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Marco Congedo, corresponding author, is a Research Director of CNRS (Centre National de la Recherche Scientifique), working at UGA (University of Grenoble Alpes). Contact: first name dot last name at gmail dot com","category":"page"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Fahim Doumi at the time of writing was a research ingeneer at the Department of Enginnering of the University federico II of Naples.","category":"page"},{"location":"#Contributors:","page":"Eegle Documentation","title":"Contributors:","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Alexandre Bleuzé","category":"page"},{"location":"#TroubleShoothing","page":"Eegle Documentation","title":"TroubleShoothing","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Problem Solution\nNo problem encountered so far N.A.","category":"page"},{"location":"#Reviewers-and-Contributors","page":"Eegle Documentation","title":"Reviewers & Contributors","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Independent reviewers for both the code and the documentation are welcome. To contribute, please check the secion How to Contribute.","category":"page"},{"location":"#Contents","page":"Eegle Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"Pages = [       \"index.md\",\n                \"Eegle.md\",\n                \"FileSystem.md\",\n                \"Preprocessing.md\",\n                \"Processing.md\",\n                \"Miscellaneous.md\",\n                \"ERPs.md\",\n                \"BCI.md\",\n                \"Database.md\",\n\t\t\t\t\"references.md\",\n\t\t]\nDepth = 1","category":"page"},{"location":"#Index","page":"Eegle Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Eegle Documentation","title":"Eegle Documentation","text":"","category":"page"},{"location":"Tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"Running the tutorials is the fastest way to learn how to use Eegle and to appreciate the way it integrates diverse packages for EEG analysis and classification.","category":"page"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"Tutorials are organized by themes; start with those more closely ressambling to your research needs at hand.","category":"page"},{"location":"Tutorials/#Things-to-know","page":"Tutorials","title":"Things to know","text":"","category":"section"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"We always fully-qualified the name of functions or give the fully-qualified name as a comment. This way you can easily spot the package where they can be found. In your code, you don't need to do that.\nFor producing figures in these tutorials we use CairoMakie or GLMakie. Install then first by executing in the REPL","category":"page"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"]add CairoMakie, GLMakie","category":"page"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"For plotting EEG traces and topographic maps we use dedicated applications running only under Windows. The output is always given as a figure so that you can follow the tutorials also if you work with another OS.","category":"page"},{"location":"Tutorials/#Themes","page":"Tutorials","title":"Themes","text":"","category":"section"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"Theme Uses\nMachine Learning typically used in the field of brain-Computer interface","category":"page"},{"location":"Tutorials/#Machine-Learning","page":"Tutorials","title":"Machine Learning","text":"","category":"section"},{"location":"Tutorials/","page":"Tutorials","title":"Tutorials","text":"Tutorial Description\nTutorial ML 1 Select databases and run a cross-validation for all sessions in all selected databases","category":"page"}]
}
