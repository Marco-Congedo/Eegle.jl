<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Event-Related Potentials ¬∑ Eegle</title><meta name="title" content="Event-Related Potentials ¬∑ Eegle"/><meta property="og:title" content="Event-Related Potentials ¬∑ Eegle"/><meta property="twitter:title" content="Event-Related Potentials ¬∑ Eegle"/><meta name="description" content="Documentation for Eegle."/><meta property="og:description" content="Documentation for Eegle."/><meta property="twitter:description" content="Documentation for Eegle."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Eegle logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Eegle</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Eegle Documentation</a></li><li><a class="tocitem" href="../Eegle/">Eegle Package</a></li><li><a class="tocitem" href="../Tutorials/">Tutorials</a></li><li><span class="tocitem">Eegle Modules</span><ul><li><a class="tocitem" href="../Preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="../Processing/">Processing</a></li><li class="is-active"><a class="tocitem" href>Event-Related Potentials</a><ul class="internal"><li><a class="tocitem" href="#ERPs.jl"><span>ERPs.jl</span></a></li><li><a class="tocitem" href="#Extract-ERPs"><span>Extract ERPs</span></a></li><li><a class="tocitem" href="#Resources-for-ERPs"><span>Resources for ERPs</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../BCI/">Brain-Computer Interface</a></li><li><a class="tocitem" href="../Database/">Database</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../InOut/">Input/Output</a></li><li><a class="tocitem" href="../FileSystem/">File System</a></li><li><a class="tocitem" href="../Miscellaneous/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Data</span><ul><li><a class="tocitem" href="../documents/Example Data/">Example Data</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">BCI DBs Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../documents/BCI Databases Overview/">BCI DBs Overview</a></li><li><a class="tocitem" href="../documents/Databases Summary MI/">databases Summary MI</a></li><li><a class="tocitem" href="../documents/TreatmentMI/">TreatmentMI</a></li><li><a class="tocitem" href="../documents/Databases Summary P300/">databases Summary P300</a></li><li><a class="tocitem" href="../documents/TreatmentP300/">TreatmentP300</a></li><li><a class="tocitem" href="../documents/yamlstruct/">NY metadata (YAML)</a></li></ul></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Eegle Modules</a></li><li class="is-active"><a href>Event-Related Potentials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Event-Related Potentials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/Eegle.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/Eegle.jl/blob/master/docs/src/ERPs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="ERPs.jl"><a class="docs-heading-anchor" href="#ERPs.jl">ERPs.jl</a><a id="ERPs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ERPs.jl" title="Permalink"></a></h2><p>This module implements basic tools fo the analysis of <strong>Event-Related Potentials</strong> (ERPs).  Many of these tolls are useful for working with tagged EEG data in general, for example, with BCI data.</p><h2 id="Extract-ERPs"><a class="docs-heading-anchor" href="#Extract-ERPs">Extract ERPs</a><a id="Extract-ERPs-1"></a><a class="docs-heading-anchor-permalink" href="#Extract-ERPs" title="Permalink"></a></h2><p>ERPs are EEG potentials time and phase-locked to the presentation of sensory stimuli.</p><p>They are extracted averaging <strong>EEG epochs</strong> (<strong>trials</strong>) of fixed duration starting at a fixed position in time with respect to the presentation of stimuli.</p><p><strong>Eegle</strong> handles two ways to extract ERPs: using a <strong>stimulation vector</strong> or using <strong>marker vectors</strong>. You can swicth from one representation to the other using the <a href="#Eegle.ERPs.stim2mark"><code>stim2mark</code></a> and <a href="#Eegle.ERPs.mark2stim"><code>mark2stim</code></a> functions.</p><h3 id="stimulation-vector"><a class="docs-heading-anchor" href="#stimulation-vector">stimulation vector</a><a id="stimulation-vector-1"></a><a class="docs-heading-anchor-permalink" href="#stimulation-vector" title="Permalink"></a></h3><p>This is an accessory channel holding as many samples as there are in the EEG recording. The value is zero everywhere, except at samples corresponding to a stimulus presentation, where the value is a natural number (1, 2, ...), each one coding a stimulus class. We name these numbers the <strong>tag</strong> of each sample.</p><pre><code class="nohighlight hljs"># Toy example of a stimulation vector for two classes
[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0]</code></pre><h3 id="marker-vectors"><a class="docs-heading-anchor" href="#marker-vectors">marker vectors</a><a id="marker-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#marker-vectors" title="Permalink"></a></h3><p>Equivalently, we can cosider a vector holding <span>$z$</span> vectors, each one listing the serial numbers of the samples belonging to each of the possible <span>$z$</span> classes.</p><pre><code class="nohighlight hljs"># Representation of the above stimulation vector as markers vector
`[[13, 18], [6]]`</code></pre><h3 id="offset"><a class="docs-heading-anchor" href="#offset">offset</a><a id="offset-1"></a><a class="docs-heading-anchor-permalink" href="#offset" title="Permalink"></a></h3><p>Several <strong>Eegle</strong> methods allow setting an <strong>offset</strong> to determine the starting sample of all evoked potentials (or trials). The offset is always to be given in samples. It can be </p><ul><li>zero (default): it does not affect the stimulations and corresponding markers, </li><li>negative: the stimulations and markers are shifted back,</li><li>positive: the stimulations and markers are shifted forth.</li></ul><pre><code class="nohighlight hljs"># Example with `offet=-3`; the above stimulation vector and marker vectors becomes
[0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]
[[10, 15], [3]]</code></pre><div class="admonition is-warning" id="Data-in-NY-format-b432d25caf6fd86e"><header class="admonition-header">Data in NY format<a class="admonition-anchor" href="#Data-in-NY-format-b432d25caf6fd86e" title="Permalink"></a></header><div class="admonition-body"><p>When data in <a href="../documents/BCI Databases Overview/#NY-format">NY format</a> is read, the offset is applied and reset to zero ‚Äî see <a href="../InOut/#Eegle.InOut.readNY"><code>readNY</code></a>.</p></div></div><h3 id="overlapping"><a class="docs-heading-anchor" href="#overlapping">overlapping</a><a id="overlapping-1"></a><a class="docs-heading-anchor-permalink" href="#overlapping" title="Permalink"></a></h3><p>The ERPs are said <strong>overlapping</strong> if the minimum inter-stimulus interval is shorter than the ERP window length, that is, if a stimulus can be presented before the preceeding evoked response has ended. In this situation, the multivariate regression (MR) method can provide better ERP estimates as compared  to the standard arithmetic average (AE) (<a href="../references/#Congedo2016STCP">Congedo <em>et al.</em>, 2016</a>).</p><p>Methods estimating ERPs in <strong>Eegle</strong> feature the <code>overlapping</code> boolean <a href="../Eegle/#Acronyms">kwarg</a>, by which you can switch between the AE (false) and MR method (true).</p><div class="admonition is-info" id="Overlapping-4207afe635b79c4"><header class="admonition-header">Overlapping<a class="admonition-anchor" href="#Overlapping-4207afe635b79c4" title="Permalink"></a></header><div class="admonition-body"><p>If the ERPs are overlapping and you set <code>overlapping</code> to true, all means should be estimated at once; In fact, the advantage of the MR method vanishes if the means are computed individually. </p><p>In general, do not set <code>overlapping</code> to true for computing only one mean, even if the stumulations are overlapping. In this case the AE and MR methods are equivalent, but the AE is faster and more accurate.</p><p>For the same reason, do not set <code>overlapping</code> to true if the ERPs do not actually overlap.</p></div></div><h2 id="Resources-for-ERPs"><a class="docs-heading-anchor" href="#Resources-for-ERPs">Resources for ERPs</a><a id="Resources-for-ERPs-1"></a><a class="docs-heading-anchor-permalink" href="#Resources-for-ERPs" title="Permalink"></a></h2><p>For <strong>classifying ERPs using Riemannian geometry</strong> ‚Äî see package <a href="https://github.com/Marco-Congedo/PosDefManifoldML.jl">PosDefManifoldML.jl</a>.</p><p>For <strong>spatial filters</strong> increasing the signal-to-noise ratio of ERPs ‚Äî see the <code>CSP</code> and <code>CSTP</code> functions in package <a href="https://github.com/Marco-Congedo/Diagonalizations.jl">Diagonalizations.jl</a> and article (<a href="../references/#Congedo2016STCP">Congedo <em>et al.</em>, 2016</a>).</p><p>For the analysis of <strong>time-locked and phase-locked components of ERPs</strong>, as well as <strong>ERP synchronization measures</strong>, in the time-frequency domain ‚Äî see package <a href="https://github.com/Marco-Congedo/FourierAnalysis.jl">FourierAnalysis.jl</a> and companion article (<a href="../references/#congedo2018non">Congedo, 2018</a>).</p><p><a href="https://github.com/unfoldtoolbox/Unfold.jl">Unfold</a> is a package dedicated to ERP analysis.</p><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#Statistics.mean"><code>Eegle.ERPs.mean</code></a></td><td style="text-align: left">compute ERPs from an EEG recording (2 methods)</td></tr><tr><td style="text-align: left"><a href="#Eegle.ERPs.stim2mark"><code>Eegle.ERPs.stim2mark</code></a></td><td style="text-align: left">convert a <a href="#stimulation-vector">stimulation vector</a> into <a href="#marker-vectors">marker vectors</a></td></tr><tr><td style="text-align: left"><a href="#Eegle.ERPs.mark2stim"><code>Eegle.ERPs.mark2stim</code></a></td><td style="text-align: left">convert <a href="#marker-vectors">marker vectors</a> into a <a href="#stimulation-vector">stimulation vector</a></td></tr><tr><td style="text-align: left"><a href="#Base.merge"><code>Eegle.ERPs.merge</code></a></td><td style="text-align: left">merge and reorganize <a href="#marker-vectors">marker vectors</a></td></tr><tr><td style="text-align: left"><a href="#Eegle.ERPs.trialsWeights"><code>Eegle.ERPs.trialsWeights</code></a></td><td style="text-align: left">compute adaptive weights for average ERP estimations</td></tr><tr><td style="text-align: left"><a href="#Eegle.ERPs.trials"><code>Eegle.ERPs.trials</code></a></td><td style="text-align: left">extract trials (e.g., ERPs) from a  tagged EEG recording</td></tr><tr><td style="text-align: left"><a href="#Eegle.ERPs.reject"><code>Eegle.ERPs.reject</code></a></td><td style="text-align: left">reject trials (e.g., ERPs) in a tagged EEG recording</td></tr></table><p>üìñ</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) function mean(  X::Matrix{T}, 
                    wl::S, 
                    mark::Vector{Vector{S}};
        overlapping :: Bool = false,
        offset :: S = 0,
        weights :: Union{Vector{Vector{R}}, Symbol}=:none) 
    where {T&lt;:Real, S&lt;:Int}

(2) function mean(  o::EEG; 
        overlapping :: Bool = false,
        offset :: S = 0,
        weights :: Union{Vector{Vector{T}}, Symbol} = :none,
        mark :: Union{Vector{Vector{S}}, Nothing} = nothing) 
    where {T&lt;:Real, S&lt;:Int}</code></pre><p>Estimate the weighted mean ERPs (event-related potentials), as the standard arithmetic mean (default)  or using the multivariate regression method, as detailed in (<a href="../references/#Congedo2016STCP">Congedo <em>et al.</em>, 2016</a>).</p><p><strong>Tutorials</strong></p><p>xxx</p><p><strong>METHOD (1)</strong></p><p><strong>Arguments</strong></p><ul><li><code>X</code>: the whole EEG recording, a matrix of size <span>$T√óN$</span>, where <span>$T$</span> and <span>$N$</span> denotes the number of samples and channels (sensors), respectively</li><li><code>wl</code>: the window (trial or ERP) length in samples</li><li><code>mark</code>: the <a href="#marker-vectors">marker vectors</a>.</li></ul><div class="admonition is-warning" id="Empty-markers-vectors-d1b7972cd201ec6b"><header class="admonition-header">Empty markers vectors<a class="admonition-anchor" href="#Empty-markers-vectors-d1b7972cd201ec6b" title="Permalink"></a></header><div class="admonition-body"><p>If <code>mark</code> holds empty vectors, they will be ignored and the mean will not be computed for those marks. The number of means therefore will be equal to the number of non-empty mark vectors.</p></div></div><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>overlapping</code>: see <a href="#overlapping">overlapping</a></li><li><code>offset</code>: see <a href="#offset">offset</a></li><li><code>weights</code>: can be used to obtain weighted means. By default, equal weights are used. It can be: <ul><li>a vector of vectors of non-negative real weights for the trials, with the same shape as <code>mark</code>, where the empty vectors of <code>mark</code> are ignored</li><li><code>:a</code> : adaptive weights computed as the inverse of the squared Frobenius norm of the trials data, along the lines of (<a href="../references/#Congedo2016STCP">Congedo <em>et al.</em>, 2016</a>).</li></ul></li></ul><div class="admonition is-warning" id="offset-dc95d37d06836342"><header class="admonition-header">offset<a class="admonition-anchor" href="#offset-dc95d37d06836342" title="Permalink"></a></header><div class="admonition-body"><p>If <code>mark</code> has been created using an offset when reading the data using <a href="../InOut/#Eegle.InOut.readNY"><code>Eegle.InOut.readNY</code></a>, set offset to zero here.</p><p>Markers which value plus the offset exceeds <span>$t$</span> minus the window length will be ignored, as they cannot define a complete ERP (or trial).</p></div></div><p><strong>Return</strong></p><p>A vector of mean ERPs, one for each non-empty vectors in <code>mark</code>. Each mean is a matrix of size  <span>$wl√ón$</span>, where <span>$n$</span> is the number of electrodes.</p><p><strong>METHOD (2)</strong> </p><p>The same as method (1), but taking as input an <a href="../InOut/#Eegle.InOut.EEG"><code>Eegle.InOut.EEG</code></a> structure <code>o</code>, which has fields providing the recording (<code>X</code>), the ERP duration in samples (<code>wl</code>) and the markers (<code>mark</code>).</p><p>Different markers can be used instead by passing <a href="#marker-vectors">marker vectors</a> with the <code>mark</code> kwarg.</p><p><strong>See</strong> <a href="#Eegle.ERPs.stim2mark">Eegle.ERPs.<code>stim2mark</code></a>, <a href="#Eegle.ERPs.trialsWeights"><code>Eegle.ERPs.trialsWeights</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs

# Method (1)

# Number of channels, sampling rate and window length
N, sr, wl = 19, 128, 128

# number of tags per class
nm=[30, 45, 28]

X=randn(sr*100, N)
mark=[[rand(1:sr*100-wl) for i=1:m] for m‚àànm]

# compute the means for all classes with adaptive weighting
ùêå=mean(X, wl, mark; overlapping=true, weights=:a)

# compute the means for class 1 and 3
ùêå=mean(X, wl, [mark[1], mark[3]]; overlapping=true)

# compute the mean  with adaptive weighting only for the first class
# and return it as a matrix (not as a vector of matrices)
M=mean(X, wl, [mark[1]]; weights=:a)[1]

# Method (2)
# xxx Load a NY file
ùêå=mean(o; overlapping=true, weights=:a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L47-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Eegle.ERPs.stim2mark" href="#Eegle.ERPs.stim2mark"><code>Eegle.ERPs.stim2mark</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function stim2mark( stim::Vector{S}, 
                        wl::S;
        offset::S=0, code=nothing) 
    where S &lt;: Int</code></pre><p>Convert a <a href="#stimulation-vector">stimulation vector</a> into <a href="#marker-vectors">marker vectors</a>.</p><p><strong>Arguments</strong></p><ul><li><code>stim</code>: the <a href="#stimulation-vector">stimulation vector</a> to be converted</li><li><code>wl</code>: the window (trial or ERP) length in samples.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>code</code>: by default, the output will hold as many marker vectors as the largest tag (integers) in <code>stim</code>,   which may or may not hold instances of all integers up to the largest.   If there are missing integers, the corresponding marker vector will be empty.   Alternatively, a vector of tags coding the classes of stimulations in <code>stim</code> can be passed as    kwarg <code>code</code>. In this case, arbitrary non-zero tags can be used (even negative)   and the number of marker vectors will be equal to the number of   unique integers in <code>code</code>. If <code>code</code> is provided, the marker vectors are arranged in the order given there,   otherwise the first vector corresponds to the tag 1, the second to tag 2, etc.   In ant case, in each vector, the samples are sorted in ascending order.</li></ul><div class="admonition is-warning" id="offset-cf01a3af97eff1a0"><header class="admonition-header">offset<a class="admonition-anchor" href="#offset-cf01a3af97eff1a0" title="Permalink"></a></header><div class="admonition-body"><p>Markers which value plus the offset is non-positive or exceeds the length of <code>stim</code> minus <span>$wl$</span> will be ignored, as they cannot define a complete ERP (or trial). If this happens, passing the output to <a href="#Eegle.ERPs.mark2stim"><code>mark2stim</code></a> will not return <code>stim</code> back exactly. Actually, calling this function and reverting the operation with <code>mark2stim</code> ensures that the  stimulation vector is valid.</p></div></div><p><strong>Return</strong></p><p>A vector of <span>$z$</span> marker vectors, where <span>$z$</span> is the number of classes, i.e., the highest integer in <code>stim</code> or the number of non-zero elements in <code>code</code> if it is provided.</p><p><strong>See</strong> <a href="#Eegle.ERPs.mark2stim"><code>mark2stim</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs

sr, wl = 128, 256 # sampling rate, window length of trials
ns = sr*100 # number of samples of the recording

# simulate a valid stimulations vector for three classes
stim = vcat([rand()&lt;0.01 ? rand(1:3) : 0 for i = 1:ns-wl], zeros(Int, wl))

mark = stim2mark(stim, wl)

stim2 = mark2stim(mark, ns) # is identical to stim</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L194-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Eegle.ERPs.mark2stim" href="#Eegle.ERPs.mark2stim"><code>Eegle.ERPs.mark2stim</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function mark2stim( mark::Vector{Vector{S}}, 
                        ns::S;
        offset::S=0, code=nothing) 
    where S &lt;: Int</code></pre><p>Reverse transformation of <a href="#Eegle.ERPs.stim2mark"><code>stim2mark</code></a>.</p><div class="admonition is-info" id="Note-6b29d8b10d49cab8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6b29d8b10d49cab8" title="Permalink"></a></header><div class="admonition-body"><p>If an <code>offset</code> has been used in <code>stim2mark</code>, -offset must be used here in order to get back to the original <a href="#stimulation-vector">stimulation vector</a>.</p></div></div><p>If <code>code</code> is provided, it must not contain 0. </p><p><strong>Examples</strong> see <a href="#Eegle.ERPs.stim2mark"><code>stim2mark</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L253-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function merge( mark::Vector{Vector{S}}, 
                    mergeClasses::Vector{Vector{S}})
    where S &lt;: Int</code></pre><p>Merge the vectors of <a href="#marker-vectors">marker vectors</a> <code>mark</code> and sort the markers within each class. Return another marker vectors. The merging pattern is determined by <code>mergeClasses</code>.</p><p>As an example, suppose <code>mark</code> holds 4 vectors of markers and <code>mergeClasses</code>=[[1, 2], [3, 4]], then the result will hold two markers vectors, vectors 1 and 2 of <code>mark</code> concatenated and sorted and vectors 3 and 4 of in <code>mark</code> concatenated and sorted. Empty mark vectors will be ignored.</p><p>This can be used to merge classes in ERP and BCI experiments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs
mark =  [   [128, 367], 
            [245, 765, 986],
            [467, 880, 1025, 1456],
            [728, 1230, 1330, 1550, 1980],  
        ]

merged = merge(mark, [[1, 2], [3, 4]])

# return: 2-element Vector{Vector{Int64}}:
#           [128, 245, 367, 765, 986]
#           [467, 728, 880, 1025, 1230, 1330, 1456, 1550, 1980]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L280-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Eegle.ERPs.trials" href="#Eegle.ERPs.trials"><code>Eegle.ERPs.trials</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function trials(X::Matrix{R}, 
                    stimOrMark::Union{Vector{S}, Vector{Vector{S}}}, 
                    wl::S;
        shape::Symbol = :cat
        weights::Union{Vector{R}, Nothing} = nothing,
        linComb::Union{Vector{R}, S, Nothing} = nothing,
        offset::S = 0) 
    where {R&lt;:Real, S&lt;:Int}
</code></pre><p>Extract trials of duration <code>wl</code> from a tagged EEG recording <code>X</code>. Optionally, multiply them by <code>weights</code> and compute a linear combination across sensors thereof.</p><div class="admonition is-success" id="Tip-b122e3bdb44431f6"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-b122e3bdb44431f6" title="Permalink"></a></header><div class="admonition-body"><p>To extract trials and compute their mean, see <a href="#Statistics.mean"><code>mean</code></a>; for segmenting non-tagged data, see <a href="../Processing/#Eegle.Processing.epoching"><code>Eegle.Processing.epoching</code></a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>X</code>: the whole EEG recording, a matrix of size <span>$T√óN$</span>, where <span>$T$</span> is the number of samples and <span>$N$</span> the number of channels (sensors).</li><li><code>stimOrMark</code>: either a <a href="#stimulation-vector">stimulation vector</a> or <a href="#marker-vectors">marker vectors</a>. </li><li><code>wl</code>: the window (trial, e.g., ERP) length in samples.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>shape</code>: see below.</li><li><code>weights</code>: optional weights to be multiplied to the trials. It has the same size as <code>stimOrMark</code>. Adaptive weights can be obtained passing the <a href="#Eegle.ERPs.trialsWeights"><code>Eegle.ERPs.trialsWeights</code></a> function.</li></ul><div class="admonition is-warning" id="Weights-normalization-9a8cc8355ed02911"><header class="admonition-header">Weights normalization<a class="admonition-anchor" href="#Weights-normalization-9a8cc8355ed02911" title="Permalink"></a></header><div class="admonition-body"><p>If you provide custom weights, their mean should be 1 across trials with the same tag if <code>stimOrMark</code> is a stimumatios vector, within each vector if they are marker vectors.</p></div></div><ul><li><code>linComb</code>: Optional linear combination to be applied to the trials, e.g., a spatial filter. It can be:<ul><li>an integer: extract for each (weighted) trial only the data at the electrode indexed by <code>linComb</code> <span>$‚àà[1,..,n]$</span> (linear combination by a one-hot vector)</li><li>a vector <span>$f$</span> of <span>$N$</span> real elements: extract for each (weighted) trial the linear combination <span>$X_jf$</span>.</li></ul></li><li><code>offset</code>: see <a href="#offset">offset</a>.</li></ul><p><strong>Return</strong></p><ul><li>if <code>stimOrMark</code> is a <a href="#stimulation-vector">stimulation vector</a>, return a vector of trials or of linear combinations thereof.</li><li>if <code>stimOrMark</code> is <a href="#marker-vectors">marker vectors</a>, return:<ul><li>a vector of vectors of trials or of linear combinations threof if <code>shape</code> ‚â† <code>:cat</code>,</li><li>all trials or the linear combinations threof concatenated in a single vector if <code>shape</code> == <code>:cat</code>.</li></ul></li></ul><p>By default <code>shape</code> is equal to <code>:cat</code>. Empty marker vectors are ignored if <code>shape</code> is equal to <code>:cat</code>, otherwise an empty vector is returned in their corresponding positions.</p><p>Each extracted trial is a <span>$wl√óN$</span> matrix if <code>linComb</code> is <code>nothing</code> (default),  otherwise it a vector <span>$wl$</span> elements.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs
xxx # </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L344-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Eegle.ERPs.trialsWeights" href="#Eegle.ERPs.trialsWeights"><code>Eegle.ERPs.trialsWeights</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function trialsWeights( X::Matrix{R}, 
                            stimOrMark::Union{Vector{S}, Vector{Vector{S}}}, 
                            wl::S;
        M::Union{Matrix{R}, Nothing} = nothing,
        offset::S = 0) 
    where {R&lt;:Real, S&lt;:Int}
</code></pre><p>Compute adaptive weights for trials as the inverse of their squared Frobenius norm, along the lines of (<a href="../references/#Congedo2016STCP">Congedo <em>et al.</em>, 2016</a>). The method is unsupervised, i.e., agnostic to class labels, but a supervised version is available using the <code>M</code> arguments.</p><div class="admonition is-success" id="Mean-ERPs-aff0690bd9c47bb3"><header class="admonition-header">Mean ERPs<a class="admonition-anchor" href="#Mean-ERPs-aff0690bd9c47bb3" title="Permalink"></a></header><div class="admonition-body"><p>You don&#39;t need this function to compute weighted mean ERPs, as this function is called by <a href="#Statistics.mean"><code>mean</code></a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>X</code>: the whole EEG recording, a matrix of size <span>$T√óN$</span>, where <span>$T$</span> is the number of samples and <span>$N$</span> the number of channels (sensors), respectively</li><li><code>stimOrMark</code>: either a <a href="#stimulation-vector">stimulation vector</a> or <a href="#marker-vectors">marker vectors</a>. For empty mark vectors, an empty vector is returned</li><li><code>wl</code>: the window (trial or ERP) length in samples.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>M</code>: (defalut = <code>nothing</code>)<ul><li>if <code>stimOrMark</code> is a stimulation vector and a matrix is passed as <code>M</code>, then the weights are computed as the squared norm of <span>$X_j-M$</span> for all trials <span>$X_j$</span>, <span>$j \in \{1, \ldots, k\}$</span>, regardless their class</li><li>if <code>stimOrMark</code> are marker vectors and a vector of <span>$z$</span> matrices is passed as <code>M</code>, then the weights are computed as the squared norm of <span>$X_{j(i)}-M_i$</span> for all trials  <span>$X_{j(i)}$</span>, <span>$j \in \{1, \ldots, k\}$</span>, <span>$i \in \{i, \ldots, z\}$</span> for each class <span>$i$</span> separately.</li></ul></li><li><code>offset</code>: see <a href="#offset">offset</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs
xxx # </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L433-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Eegle.ERPs.reject" href="#Eegle.ERPs.reject"><code>Eegle.ERPs.reject</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function reject(X::Matrix{R}, 
                    stim::Vector{Int}, 
                    wl::S;
        offset::S = 0,
        upperLimit::Union{R, S} = 1.2,
        returnDetails::Bool=false) 
    where {R&lt;:Real, S&lt;:Int}</code></pre><p>Automatic rejection of artefacted trials in tagged EEG data by automatic amplitude thresholding.</p><div class="admonition is-success" id="Read-data-and-reject-artifacts-e795ea60ac5df512"><header class="admonition-header">Read data and reject artifacts<a class="admonition-anchor" href="#Read-data-and-reject-artifacts-e795ea60ac5df512" title="Permalink"></a></header><div class="admonition-body"><p>This function is called by <a href="../InOut/#Eegle.InOut.readNY"><code>Eegle.InOut.readNY</code></a> to perform artifact rejection while reading EEG data in the <a href="../documents/BCI Databases Overview/#NY-format">NY format</a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>X</code>: the whole EEG recording, a matrix of size <span>$T√óN$</span>, where <span>$T$</span> is the number of samples and <span>$N$</span> the number of electrodes</li><li><code>stim</code>: a <a href="#stimulation-vector">stimulation vector</a></li><li><code>wl</code>: the trial length, i.e., the ERPs or trial duration, in samples.</li></ul><p><strong>Optioanl Keyword Arguments</strong></p><ul><li><code>offset</code>: see <a href="#offset">offset</a></li><li><code>upperLimit</code>: modulate the definition of the upper threshold (see below). a reasonable value ‚àà[1, 1.6]</li><li><code>upperLimit</code>: determine the output (see below).</li></ul><p><strong>Description</strong></p><p>Let <span>$v$</span> be the natural logarithm of the <strong>field root mean square</strong> (FRMS, see <a href="../Processing/#Eegle.Processing.globalFieldRMS"><code>Eegle.Processing.globalFieldRMS</code></a>) of <code>X</code> sorted in ascending order.</p><p>The lower threshold <span>$l$</span> is defined as the tenth value of <span>$v$</span> (robust minimum estimator).</p><p>The upper threshold <span>$h$</span> is defined as</p><p><span>$h=m+((m-l)u)$</span>,</p><p>where:</p><ul><li><span>$m$</span> is the mean of the <span>$2wl$</span> central values of <span>$v$</span>, taken as a robust central tendency estimator</li><li><span>$u$</span> is <a href="../Eegle/#Acronyms">kwarg</a> <code>upperlimit</code> (default=1.2).</li></ul><p>All trials in which at least one sample of the log-FRMS exceeds <span>$h$</span> or in which <span>$l$</span> exceeds the log-FRMS are rejected.</p><p><strong>Return</strong></p><ul><li>if <code>returnDetails</code> is false (default), a 5-tuple holding the following objects:<ul><li>the <a href="#stimulation-vector">stimulation vector</a> <code>stim</code> with the tags corresponding to rejected trials set to zero (accepted trials),</li><li>the <a href="#stimulation-vector">stimulation vector</a> <code>stim</code> with the tags corresponding to accepted trials set to zero (rejected trials),</li><li>the first object as <a href="#marker-vectors">marker vectors</a>,</li><li>the second object as <a href="#marker-vectors">marker vectors</a>,</li><li>the number of rejected trials per class as a vector of integers.</li></ul></li><li>if <code>returnDetails</code> is true, a 9-tuple holding the above 5 objects and, in addition:<ul><li>the log-FMRS (not sorted),</li><li>the mean <span>$m$</span>,</li><li>the lower threshold <span>$l$</span>,</li><li>the upper threshold <span>$h$</span>.</li></ul></li></ul><div class="admonition is-success" id="Algebraic-relation-ff53eabe33b42040"><header class="admonition-header">Algebraic relation<a class="admonition-anchor" href="#Algebraic-relation-ff53eabe33b42040" title="Permalink"></a></header><div class="admonition-body"><p>The elemet-wise sum of the first two returned objects is equal to the input <a href="#stimulation-vector">stimulation vector</a> <code>stim</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Eegle # or using Eegle.ERPs

xxx

cleanstim, rejecstim, cleanmark, rejecmark, rejected = reject(X, stim, wl; upperLimit=1.5)

R = reject(X, stim, wl; upperLimit=1.5, returnDetails = true) # R is a tuple of 9 objects

norm((R[1].+R[2]).-stim)==0 # should be true</code></pre><p><strong>Tutorials</strong></p><p>xxx</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Eegle.jl/blob/345efd3c81a9ce557f725f67c9f261b84bc5759d/src/ERPs.jl#L495-L569">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Processing/">¬´ Processing</a><a class="docs-footer-nextpage" href="../BCI/">Brain-Computer Interface ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Monday 7 July 2025 07:16">Monday 7 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
